{
  "ert\\geometry\\geo_pointset.hpp": [
    {
      "ret": "geo_pointset_type *",
      "name": "geo_pointset_alloc",
      "args": "bool external_z"
    },
    {
      "ret": "void",
      "name": "geo_pointset_free",
      "args": "geo_pointset_type *pointset"
    },
    {
      "ret": "void",
      "name": "geo_pointset_add_xyz",
      "args": "geo_pointset_type *pointset, double x, double y, double z"
    },
    {
      "ret": "int",
      "name": "geo_pointset_get_size",
      "args": "const geo_pointset_type *pointset"
    },
    {
      "ret": "void",
      "name": "geo_pointset_iget_xy",
      "args": "const geo_pointset_type *pointset, int index, double *x, double *y"
    },
    {
      "ret": "const double *",
      "name": "geo_pointset_get_zcoord",
      "args": "const geo_pointset_type *pointset"
    },
    {
      "ret": "bool",
      "name": "geo_pointset_equal",
      "args": "const geo_pointset_type *pointset1, const geo_pointset_type *pointset2"
    },
    {
      "ret": "double",
      "name": "geo_pointset_iget_z",
      "args": "const geo_pointset_type *pointset, int index"
    },
    {
      "ret": "void",
      "name": "geo_pointset_iset_z",
      "args": "geo_pointset_type *pointset, int index, double value"
    },
    {
      "ret": "void",
      "name": "geo_pointset_memcpy",
      "args": "const geo_pointset_type *src, geo_pointset_type *target, bool copy_zdata"
    },
    {
      "ret": "void",
      "name": "geo_pointset_shift_z",
      "args": "geo_pointset_type *pointset, double value"
    },
    {
      "ret": "void",
      "name": "geo_pointset_assign_z",
      "args": "geo_pointset_type *pointset, double value"
    },
    {
      "ret": "void",
      "name": "geo_pointset_scale_z",
      "args": "geo_pointset_type *pointset, double value"
    },
    {
      "ret": "void",
      "name": "geo_pointset_imul",
      "args": "geo_pointset_type *pointset, const geo_pointset_type *other"
    },
    {
      "ret": "void",
      "name": "geo_pointset_iadd",
      "args": "geo_pointset_type *pointset, const geo_pointset_type *other"
    },
    {
      "ret": "void",
      "name": "geo_pointset_isub",
      "args": "geo_pointset_type *self, const geo_pointset_type *other"
    },
    {
      "ret": "void",
      "name": "geo_pointset_isqrt",
      "args": "geo_pointset_type *pointset"
    }
  ],
  "ert\\geometry\\geo_polygon.hpp": [
    {
      "ret": "geo_polygon_type *",
      "name": "geo_polygon_alloc",
      "args": "const char *name"
    },
    {
      "ret": "void",
      "name": "geo_polygon_free",
      "args": "geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_polygon_free__",
      "args": "void *arg"
    },
    {
      "ret": "void",
      "name": "geo_polygon_add_point",
      "args": "geo_polygon_type *polygon, double x, double y"
    },
    {
      "ret": "void",
      "name": "geo_polygon_add_point_front",
      "args": "geo_polygon_type *polygon, double x, double y"
    },
    {
      "ret": "geo_polygon_type *",
      "name": "geo_polygon_fload_alloc_irap",
      "args": "const char *filename"
    },
    {
      "ret": "bool",
      "name": "geo_polygon_contains_point",
      "args": "const geo_polygon_type *polygon, double x, double y"
    },
    {
      "ret": "bool",
      "name": "geo_polygon_contains_point__",
      "args": "const geo_polygon_type *polygon, double x, double y, bool force_edge_inside"
    },
    {
      "ret": "void",
      "name": "geo_polygon_reset",
      "args": "geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_polygon_close",
      "args": "geo_polygon_type *polygoon"
    },
    {
      "ret": "int",
      "name": "geo_polygon_get_size",
      "args": "const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_polygon_iget_xy",
      "args": "const geo_polygon_type *polygon, int index, double *x, double *y"
    },
    {
      "ret": "bool",
      "name": "geo_polygon_segment_intersects",
      "args": "const geo_polygon_type *polygon, double x1, double y1, double x2, double y2"
    },
    {
      "ret": "const char *",
      "name": "geo_polygon_get_name",
      "args": "const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_polygon_set_name",
      "args": "geo_polygon_type *polygon, const char *name"
    },
    {
      "ret": "double",
      "name": "geo_polygon_get_length",
      "args": "geo_polygon_type *polygon"
    },
    {
      "ret": "bool",
      "name": "geo_polygon_equal",
      "args": "const geo_polygon_type *polygon1, const geo_polygon_type *polygon2"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "geo_polygon"
    }
  ],
  "ert\\geometry\\geo_polygon_collection.hpp": [
    {
      "ret": "void",
      "name": "geo_polygon_collection_free",
      "args": "geo_polygon_collection_type *polygons"
    },
    {
      "ret": "int",
      "name": "geo_polygon_collection_size",
      "args": "const geo_polygon_collection_type *polygons"
    },
    {
      "ret": "geo_polygon_type *",
      "name": "geo_polygon_collection_create_polygon",
      "args": "geo_polygon_collection_type *polygons, const char *name"
    },
    {
      "ret": "bool",
      "name": "geo_polygon_collection_has_polygon",
      "args": "const geo_polygon_collection_type *polygons, const char *name"
    },
    {
      "ret": "bool",
      "name": "geo_polygon_collection_add_polygon",
      "args": "geo_polygon_collection_type *polygons, geo_polygon_type *polygon, bool polygon_owner"
    },
    {
      "ret": "geo_polygon_type *",
      "name": "geo_polygon_collection_iget_polygon",
      "args": "const geo_polygon_collection_type *polygons, int index"
    },
    {
      "ret": "geo_polygon_type *",
      "name": "geo_polygon_collection_get_polygon",
      "args": "const geo_polygon_collection_type *polygons, const char *polygon_name"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "geo_polygon_collection"
    }
  ],
  "ert\\geometry\\geo_region.hpp": [
    {
      "ret": "geo_region_type *",
      "name": "geo_region_alloc",
      "args": "const geo_pointset_type *pointset, bool preselect"
    },
    {
      "ret": "void",
      "name": "geo_region_free",
      "args": "geo_region_type *region"
    },
    {
      "ret": "void",
      "name": "geo_region_reset",
      "args": "geo_region_type *region"
    },
    {
      "ret": "const int_vector_type *",
      "name": "geo_region_get_index_list",
      "args": "geo_region_type *region"
    },
    {
      "ret": "void",
      "name": "geo_region_select_inside_polygon",
      "args": "geo_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_region_select_outside_polygon",
      "args": "geo_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_region_deselect_inside_polygon",
      "args": "geo_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_region_deselect_outside_polygon",
      "args": "geo_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "geo_region_select_above_line",
      "args": "geo_region_type *region, const double xcoords[2], const double ycoords[2]"
    },
    {
      "ret": "void",
      "name": "geo_region_select_below_line",
      "args": "geo_region_type *region, const double xcoords[2], const double ycoords[2]"
    },
    {
      "ret": "void",
      "name": "geo_region_deselect_above_line",
      "args": "geo_region_type *region, const double xcoords[2], const double ycoords[2]"
    },
    {
      "ret": "void",
      "name": "geo_region_deselect_below_line",
      "args": "geo_region_type *region, const double xcoords[2], const double ycoords[2]"
    }
  ],
  "ert\\geometry\\geo_surface.hpp": [
    {
      "ret": "bool",
      "name": "geo_surface_equal_header",
      "args": "const geo_surface_type *surface1, const geo_surface_type *surface2"
    },
    {
      "ret": "bool",
      "name": "geo_surface_equal",
      "args": "const geo_surface_type *surface1, const geo_surface_type *surface2"
    },
    {
      "ret": "void",
      "name": "geo_surface_free",
      "args": "geo_surface_type *geo_surface"
    },
    {
      "ret": "geo_pointset_type *",
      "name": "geo_surface_get_pointset",
      "args": "const geo_surface_type *surface"
    },
    {
      "ret": "geo_surface_type *",
      "name": "geo_surface_fload_alloc_irap",
      "args": "const char *filename, bool loadz"
    },
    {
      "ret": "geo_surface_type *",
      "name": "geo_surface_alloc_new",
      "args": "int nx, int ny, double xinc, double yinc, double xstart, double ystart, double angle"
    },
    {
      "ret": "bool",
      "name": "geo_surface_fload_irap_zcoord",
      "args": "const geo_surface_type *surface, const char *filename, double *zlist"
    },
    {
      "ret": "double",
      "name": "geo_surface_iget_zvalue",
      "args": "const geo_surface_type *surface, int index"
    },
    {
      "ret": "int",
      "name": "geo_surface_get_size",
      "args": "const geo_surface_type *surface"
    },
    {
      "ret": "void",
      "name": "geo_surface_fprintf_irap",
      "args": "const geo_surface_type *surface, const char *filename"
    },
    {
      "ret": "int",
      "name": "geo_surface_get_nx",
      "args": "const geo_surface_type *surface"
    },
    {
      "ret": "int",
      "name": "geo_surface_get_ny",
      "args": "const geo_surface_type *surface"
    },
    {
      "ret": "void",
      "name": "geo_surface_iget_xy",
      "args": "const geo_surface_type *surface, int index, double *x, double *y"
    },
    {
      "ret": "void",
      "name": "geo_surface_shift",
      "args": "const geo_surface_type *src, double value"
    },
    {
      "ret": "void",
      "name": "geo_surface_scale",
      "args": "const geo_surface_type *src, double value"
    },
    {
      "ret": "void",
      "name": "geo_surface_isub",
      "args": "geo_surface_type *self, const geo_surface_type *other"
    },
    {
      "ret": "void",
      "name": "geo_surface_iset_zvalue",
      "args": "geo_surface_type *surface, int index, double value"
    },
    {
      "ret": "void",
      "name": "geo_surface_assign_value",
      "args": "const geo_surface_type *src, double value"
    },
    {
      "ret": "geo_surface_type *",
      "name": "geo_surface_alloc_copy",
      "args": "const geo_surface_type *src, bool copy_zdata"
    },
    {
      "ret": "void",
      "name": "geo_surface_iadd",
      "args": "geo_surface_type *self, const geo_surface_type *other"
    },
    {
      "ret": "void",
      "name": "geo_surface_imul",
      "args": "geo_surface_type *self, const geo_surface_type *other"
    },
    {
      "ret": "void",
      "name": "geo_surface_isqrt",
      "args": "geo_surface_type *surface"
    }
  ],
  "ert\\geometry\\geo_util.hpp": [
    {
      "ret": "bool",
      "name": "geo_util_inside_polygon__",
      "args": "const double *xlist, const double *ylist, int num_points, double x0, double y0, bool force_edge_inside"
    },
    {
      "ret": "geo_util_xlines_status_enum",
      "name": "geo_util_xlines",
      "args": "const double **points, double *x0, double *y0"
    },
    {
      "ret": "geo_util_xlines_status_enum",
      "name": "geo_util_xsegments",
      "args": "const double **points, double *x0, double *y0"
    }
  ],
  "ert\\util\\hash.hpp": [
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "hash"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER_CONST",
      "args": "hash"
    },
    {
      "ret": "hash_type *",
      "name": "hash_alloc",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "hash_free",
      "args": "hash_type *"
    },
    {
      "ret": "void",
      "name": "hash_insert_ref",
      "args": "hash_type *, const char *, const void *"
    },
    {
      "ret": "void",
      "name": "hash_insert_string",
      "args": "hash_type *, const char *, const char *"
    },
    {
      "ret": "bool",
      "name": "hash_has_key",
      "args": "const hash_type *, const char *"
    },
    {
      "ret": "void *",
      "name": "hash_get",
      "args": "const hash_type *, const char *"
    },
    {
      "ret": "char *",
      "name": "hash_get_string",
      "args": "const hash_type *, const char *"
    },
    {
      "ret": "int",
      "name": "hash_get_size",
      "args": "const hash_type *"
    },
    {
      "ret": "stringlist_type *",
      "name": "hash_alloc_stringlist",
      "args": "const hash_type *"
    },
    {
      "ret": "void",
      "name": "hash_insert_hash_owned_ref",
      "args": "hash_type *, const char *, const void *, free_ftype *"
    },
    {
      "ret": "void",
      "name": "hash_resize",
      "args": "hash_type *hash, int new_size"
    },
    {
      "ret": "void",
      "name": "hash_insert_int",
      "args": "hash_type *, const char *, int"
    },
    {
      "ret": "int",
      "name": "hash_get_int",
      "args": "const hash_type *, const char *"
    },
    {
      "ret": "void",
      "name": "hash_insert_double",
      "args": "hash_type *, const char *, double"
    },
    {
      "ret": "double",
      "name": "hash_get_double",
      "args": "const hash_type *, const char *"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "hash"
    }
  ],
  "ert\\util\\hash_node.hpp": [
    {
      "ret": "bool",
      "name": "hash_node_key_eq",
      "args": "const hash_node_type *, uint32_t, const char *"
    },
    {
      "ret": "hash_node_type *",
      "name": "hash_node_get_next",
      "args": "const hash_node_type *"
    },
    {
      "ret": "void",
      "name": "hash_node_set_next",
      "args": "hash_node_type *, const hash_node_type *"
    },
    {
      "ret": "hash_node_type *",
      "name": "hash_node_alloc_new",
      "args": "const char *, node_data_type *, hashf_type *, uint32_t"
    },
    {
      "ret": "uint32_t",
      "name": "hash_node_get_table_index",
      "args": "const hash_node_type *"
    },
    {
      "ret": "const char *",
      "name": "hash_node_get_key",
      "args": "const hash_node_type *"
    },
    {
      "ret": "node_data_type *",
      "name": "hash_node_get_data",
      "args": "const hash_node_type *"
    },
    {
      "ret": "void",
      "name": "hash_node_free",
      "args": "hash_node_type *"
    },
    {
      "ret": "uint32_t",
      "name": "hash_node_set_table_index",
      "args": "hash_node_type *, uint32_t"
    }
  ],
  "ert\\util\\hash_sll.hpp": [
    {
      "ret": "hash_sll_type **",
      "name": "hash_sll_alloc_table",
      "args": "int"
    },
    {
      "ret": "void",
      "name": "hash_sll_del_node",
      "args": "hash_sll_type *, hash_node_type *"
    },
    {
      "ret": "void",
      "name": "hash_sll_add_node",
      "args": "hash_sll_type *, hash_node_type *"
    },
    {
      "ret": "void",
      "name": "hash_sll_free",
      "args": "hash_sll_type *"
    },
    {
      "ret": "bool",
      "name": "hash_sll_empty",
      "args": "const hash_sll_type *hash_sll"
    },
    {
      "ret": "hash_node_type *",
      "name": "hash_sll_get",
      "args": "const hash_sll_type *, uint32_t, const char *"
    },
    {
      "ret": "hash_node_type *",
      "name": "hash_sll_get_head",
      "args": "const hash_sll_type *"
    }
  ],
  "ert\\util\\lookup_table.hpp": [
    {
      "ret": "lookup_table_type *",
      "name": "lookup_table_alloc",
      "args": "double_vector_type *x, double_vector_type *y, bool data_owner"
    },
    {
      "ret": "void",
      "name": "lookup_table_append",
      "args": "lookup_table_type *lt, double x, double y"
    },
    {
      "ret": "void",
      "name": "lookup_table_free",
      "args": "lookup_table_type *lt"
    },
    {
      "ret": "double",
      "name": "lookup_table_interp",
      "args": "lookup_table_type *lt, double x"
    },
    {
      "ret": "double",
      "name": "lookup_table_get_max_value",
      "args": "lookup_table_type *lookup_table"
    },
    {
      "ret": "double",
      "name": "lookup_table_get_min_value",
      "args": "lookup_table_type *lookup_table"
    },
    {
      "ret": "double",
      "name": "lookup_table_get_max_arg",
      "args": "lookup_table_type *lookup_table"
    },
    {
      "ret": "double",
      "name": "lookup_table_get_min_arg",
      "args": "lookup_table_type *lookup_table"
    },
    {
      "ret": "int",
      "name": "lookup_table_get_size",
      "args": "const lookup_table_type *lt"
    },
    {
      "ret": "void",
      "name": "lookup_table_set_low_limit",
      "args": "lookup_table_type *lt, double limit"
    },
    {
      "ret": "bool",
      "name": "lookup_table_has_low_limit",
      "args": "const lookup_table_type *lt"
    },
    {
      "ret": "void",
      "name": "lookup_table_set_high_limit",
      "args": "lookup_table_type *lt, double limit"
    },
    {
      "ret": "bool",
      "name": "lookup_table_has_high_limit",
      "args": "const lookup_table_type *lt"
    }
  ],
  "ert\\util\\mzran.hpp": [
    {
      "ret": "void",
      "name": "mzran_fscanf_state",
      "args": "void *__rng, FILE *stream"
    },
    {
      "ret": "unsigned int",
      "name": "mzran_forward",
      "args": "void *__rng"
    },
    {
      "ret": "void *",
      "name": "mzran_alloc",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "mzran_set_state",
      "args": "void *__rng, const char *seed_buffer"
    },
    {
      "ret": "void",
      "name": "mzran_get_state",
      "args": "void *__rng, char *state_buffer"
    },
    {
      "ret": "double",
      "name": "mzran_get_double",
      "args": "mzran_type *rng"
    },
    {
      "ret": "int",
      "name": "mzran_get_int",
      "args": "mzran_type *rng, int max"
    },
    {
      "ret": "void",
      "name": "mzran_fprintf_state",
      "args": "const void *__rng, FILE *stream"
    },
    {
      "ret": "void",
      "name": "mzran_free",
      "args": "void *__rng"
    }
  ],
  "ert\\util\\node_data.hpp": [
    {
      "ret": "void",
      "name": "node_data_free",
      "args": "node_data_type *"
    },
    {
      "ret": "void",
      "name": "node_data_free_container",
      "args": "node_data_type *"
    },
    {
      "ret": "node_data_type *",
      "name": "node_data_alloc_copy",
      "args": "const node_data_type *node, bool deep_copy"
    },
    {
      "ret": "void *",
      "name": "node_data_get_ptr",
      "args": "const node_data_type *"
    },
    {
      "ret": "node_data_type *",
      "name": "node_data_alloc_buffer",
      "args": "const void *, int"
    },
    {
      "ret": "node_data_type *",
      "name": "node_data_alloc_ptr",
      "args": "const void *, copyc_ftype *, free_ftype *"
    },
    {
      "ret": "node_data_type *",
      "name": "node_data_alloc_int",
      "args": "int"
    },
    {
      "ret": "int",
      "name": "node_data_get_int",
      "args": "const node_data_type *"
    },
    {
      "ret": "node_data_type *",
      "name": "node_data_alloc_double",
      "args": "double"
    },
    {
      "ret": "double",
      "name": "node_data_get_double",
      "args": "const node_data_type *"
    },
    {
      "ret": "node_data_type *",
      "name": "node_data_alloc_string",
      "args": "const char *"
    },
    {
      "ret": "char *",
      "name": "node_data_get_string",
      "args": "const node_data_type *"
    }
  ],
  "ert\\util\\parser.hpp": [
    {
      "ret": "void",
      "name": "basic_parser_free",
      "args": "basic_parser_type *parser"
    },
    {
      "ret": "stringlist_type *",
      "name": "basic_parser_tokenize_buffer",
      "args": "const basic_parser_type *parser, const char *buffer, bool strip_quote_marks"
    },
    {
      "ret": "bool",
      "name": "basic_parser_fseek_string",
      "args": "const basic_parser_type *parser, FILE *stream, const char *string, bool skip_string, bool case_sensitive"
    }
  ],
  "ert\\util\\path_stack.hpp": [
    {
      "ret": "void",
      "name": "path_stack_pop",
      "args": "path_stack_type *path_stack"
    },
    {
      "ret": "void",
      "name": "path_stack_push_cwd",
      "args": "path_stack_type *path_stack"
    },
    {
      "ret": "bool",
      "name": "path_stack_push",
      "args": "path_stack_type *path_stack, const char *path"
    },
    {
      "ret": "void",
      "name": "path_stack_free",
      "args": "path_stack_type *path_stack"
    },
    {
      "ret": "int",
      "name": "path_stack_size",
      "args": "const path_stack_type *path_stack"
    }
  ],
  "ert\\util\\perm_vector.hpp": [
    {
      "ret": "perm_vector_type *",
      "name": "perm_vector_alloc",
      "args": "int *perm_input, int size"
    },
    {
      "ret": "void",
      "name": "perm_vector_free",
      "args": "perm_vector_type *perm_vector"
    },
    {
      "ret": "int",
      "name": "perm_vector_get_size",
      "args": "const perm_vector_type *perm"
    },
    {
      "ret": "int",
      "name": "perm_vector_iget",
      "args": "const perm_vector_type *perm, int index"
    }
  ],
  "ert\\util\\rng.hpp": [
    {
      "ret": "rng_type *",
      "name": "rng_alloc",
      "args": "rng_alg_type type, rng_init_mode init_mode"
    },
    {
      "ret": "void",
      "name": "rng_free",
      "args": "rng_type *rng"
    },
    {
      "ret": "unsigned int",
      "name": "rng_forward",
      "args": "rng_type *rng"
    },
    {
      "ret": "double",
      "name": "rng_get_double",
      "args": "rng_type *rng"
    },
    {
      "ret": "void",
      "name": "rng_init",
      "args": "rng_type *rng, rng_init_mode init_mode"
    },
    {
      "ret": "int",
      "name": "rng_state_size",
      "args": "const rng_type *rng"
    },
    {
      "ret": "void",
      "name": "rng_save_state",
      "args": "rng_type *rng, const char *filename"
    },
    {
      "ret": "void",
      "name": "rng_load_state",
      "args": "rng_type *rng, const char *filename"
    },
    {
      "ret": "void",
      "name": "rng_set_state",
      "args": "rng_type *rng, const char *state"
    },
    {
      "ret": "void",
      "name": "rng_get_state",
      "args": "const rng_type *rng, char *state"
    },
    {
      "ret": "int",
      "name": "rng_get_int",
      "args": "rng_type *rng, int max_value"
    },
    {
      "ret": "unsigned int",
      "name": "rng_get_max_int",
      "args": "const rng_type *rng"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "rng"
    }
  ],
  "ert\\util\\stringlist.hpp": [
    {
      "ret": "int",
      "name": "stringlist_select_files",
      "args": "stringlist_type *names, const char *path, file_pred_ftype *predicate, const void *pred_arg"
    },
    {
      "ret": "const char *",
      "name": "stringlist_get_last",
      "args": "const stringlist_type *stringlist"
    },
    {
      "ret": "char *",
      "name": "stringlist_pop",
      "args": "stringlist_type *stringlist"
    },
    {
      "ret": "stringlist_type *",
      "name": "stringlist_alloc_new",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "stringlist_free",
      "args": "stringlist_type *"
    },
    {
      "ret": "void",
      "name": "stringlist_clear",
      "args": "stringlist_type *"
    },
    {
      "ret": "void",
      "name": "stringlist_append_copy",
      "args": "stringlist_type *, const char *"
    },
    {
      "ret": "const char *",
      "name": "stringlist_iget",
      "args": "const stringlist_type *, int"
    },
    {
      "ret": "double",
      "name": "stringlist_iget_as_double",
      "args": "const stringlist_type *stringlist, int index, bool *valid"
    },
    {
      "ret": "char *",
      "name": "stringlist_iget_copy",
      "args": "const stringlist_type *stringlist, int"
    },
    {
      "ret": "const char *",
      "name": "stringlist_front",
      "args": "const stringlist_type *stringlist"
    },
    {
      "ret": "const char *",
      "name": "stringlist_back",
      "args": "const stringlist_type *stringlist"
    },
    {
      "ret": "void",
      "name": "stringlist_iset_copy",
      "args": "stringlist_type *, int index, const char *"
    },
    {
      "ret": "int",
      "name": "stringlist_get_size",
      "args": "const stringlist_type *"
    },
    {
      "ret": "stringlist_type *",
      "name": "stringlist_alloc_argv_copy",
      "args": "const char **, int"
    },
    {
      "ret": "bool",
      "name": "stringlist_equal",
      "args": "const stringlist_type *, const stringlist_type *"
    },
    {
      "ret": "bool",
      "name": "stringlist_contains",
      "args": "const stringlist_type *, const char *"
    },
    {
      "ret": "int",
      "name": "stringlist_find_first",
      "args": "const stringlist_type *, const char *"
    },
    {
      "ret": "void",
      "name": "stringlist_sort",
      "args": "stringlist_type *, string_cmp_ftype *string_cmp"
    },
    {
      "ret": "void",
      "name": "stringlist_reverse",
      "args": "stringlist_type *s"
    },
    {
      "ret": "void",
      "name": "stringlist_python_sort",
      "args": "stringlist_type *s, int cmp_flag"
    },
    {
      "ret": "int",
      "name": "stringlist_select_matching_files",
      "args": "stringlist_type *names, const char *path, const char *file_pattern"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "stringlist"
    }
  ],
  "ert\\util\\string_util.hpp": [
    {
      "ret": "int_vector_type *",
      "name": "string_util_alloc_active_list",
      "args": "const char *range_string"
    },
    {
      "ret": "bool",
      "name": "string_util_update_active_mask",
      "args": "const char *range_string, bool_vector_type *active_mask"
    },
    {
      "ret": "bool_vector_type *",
      "name": "string_util_alloc_active_mask",
      "args": "const char *range_string"
    },
    {
      "ret": "int_vector_type *",
      "name": "string_util_alloc_value_list",
      "args": "const char *range_string"
    }
  ],
  "ert\\util\\test_util.hpp": [
    {
      "ret": "void *",
      "name": "test_argpack_is_stringlist",
      "args": "void *arg"
    },
    {
      "ret": "void *",
      "name": "thread_pool_test_func1",
      "args": "void *arg"
    },
    {
      "ret": "",
      "name": "test_assert_string_equal__",
      "args": "s1, s2, __FILE__, __LINE__) void test_assert_string_equal__(const char *s1, const char *s2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_string_not_equal__",
      "args": "s1, s2, __FILE__, __LINE__) void test_assert_string_not_equal__(const char *s1, const char *s2, const char *file, int line"
    },
    {
      "ret": "bool",
      "name": "test_check_string_equal",
      "args": "const char *s1, const char *s2"
    },
    {
      "ret": "",
      "name": "test_assert_int_equal__",
      "args": "(i1), (i2), __FILE__, __LINE__) void test_assert_int_equal__(int i1, int i2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_int_not_equal__",
      "args": "(i1), (i2), __FILE__, __LINE__) void test_assert_int_not_equal__(int i1, int i2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_long_equal__",
      "args": "(i1), (i2), __FILE__, __LINE__) void test_assert_long_equal__(long i1, long i2, const char *file, long line"
    },
    {
      "ret": "",
      "name": "test_assert_long_not_equal__",
      "args": "(i1), (i2), __FILE__, __LINE__) void test_assert_long_not_equal__(long i1, long i2, const char *file, long line"
    },
    {
      "ret": "",
      "name": "test_assert_uint_equal__",
      "args": "(i1), (i2), __FILE__, __LINE__) void test_assert_uint_equal__(unsigned int i1, unsigned int i2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_uint_not_equal__",
      "args": "(i1), (i2), __FILE__, __LINE__) void test_assert_uint_not_equal__(unsigned int i1, unsigned int i2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_size_t_equal__",
      "args": "(s1), (s2), __FILE__, __LINE__) void test_assert_size_t_equal__(size_t s1, size_t s2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_size_t_not_equal__",
      "args": "(s1), (s2), __FILE__, __LINE__) void test_assert_size_t_not_equal__(size_t s1, size_t s2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_double_equal__",
      "args": "(d1), (d2), __FILE__, __LINE__) void test_assert_double_equal__(double d1, double d2, const char *file, int line"
    },
    {
      "ret": "bool",
      "name": "test_check_double_equal",
      "args": "double d1, double d2"
    },
    {
      "ret": "",
      "name": "test_assert_float_equal__",
      "args": "(d1), (d2), __FILE__, __LINE__) void test_assert_float_equal__(float d1, float d2, const char *file, int line"
    },
    {
      "ret": "bool",
      "name": "test_check_float_equal",
      "args": "float d1, float d2"
    },
    {
      "ret": "",
      "name": "test_assert_double_not_equal__",
      "args": "(d1), (d2), __FILE__, __LINE__) void test_assert_double_not_equal__(double d1, double d2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_bool_equal__",
      "args": "(b1), (b2), __FILE__, __LINE__) void test_assert_bool_equal__(bool b1, bool b2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_bool_not_equal__",
      "args": "(b1), (b2), __FILE__, __LINE__) void test_assert_bool_not_equal__(bool b1, bool b2, const char *file, int line"
    },
    {
      "ret": "#define",
      "name": "test_assert_true",
      "args": "value) test_assert_true__((value), __FILE__, __LINE__"
    },
    {
      "ret": "void",
      "name": "test_assert_true__",
      "args": "bool value, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_false__",
      "args": "(value), __FILE__, __LINE__) void test_assert_false__(bool value, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_time_t_equal__",
      "args": "(t1), (t2), __FILE__, __LINE__) void test_assert_time_t_equal__(time_t t1, time_t t2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_time_t_not_equal__",
      "args": "(t1), (t2), __FILE__, __LINE__) void test_assert_time_t_not_equal__(time_t t1, time_t t2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_ptr_equal__",
      "args": "(p1), (p2), __FILE__, __LINE__) void test_assert_ptr_equal__(const void *p1, const void *p2, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_ptr_not_equal__",
      "args": "(p1), (p2), __FILE__, __LINE__) void test_assert_ptr_not_equal__(const void *p1, const void *p2, const char *file, int line"
    },
    {
      "ret": "#define",
      "name": "test_assert_NULL",
      "args": "p) test_assert_NULL__((p), __FILE__, __LINE__"
    },
    {
      "ret": "void",
      "name": "test_assert_NULL__",
      "args": "const void *p, const char *file, int line"
    },
    {
      "ret": "#define",
      "name": "test_assert_not_NULL",
      "args": "p) test_assert_not_NULL__((p), __FILE__, __LINE__"
    },
    {
      "ret": "void",
      "name": "test_assert_not_NULL__",
      "args": "const void *p, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_mem_equal__",
      "args": "(p1), (p2), (byte_size), __FILE__, __LINE__) void test_assert_mem_equal__(const void *p1, const void *p2, size_t byte_size, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_mem_not_equal__",
      "args": "(p1), (p2), (byte_size), __FILE__, __LINE__) void test_assert_mem_not_equal__(const void *p1, const void *p2, size_t byte_size, const char *file, int line"
    },
    {
      "ret": "",
      "name": "test_assert_file_content__",
      "args": "input_file, expected, __FILE__, __LINE__) void test_assert_file_content__(const char *input_file, const char *expected, const char *src_file, int line"
    },
    {
      "ret": "void",
      "name": "test_install_SIGNALS",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "test_assert_util_abort",
      "args": "const char *function_name, void call_func(void *), void *arg"
    }
  ],
  "ert\\util\\test_work_area.hpp": [
    {
      "ret": "test_work_area_type *",
      "name": "test_work_area_alloc",
      "args": "const char *test_name"
    },
    {
      "ret": "test_work_area_type *",
      "name": "test_work_area_alloc__",
      "args": "const char *test_name, bool store_area"
    },
    {
      "ret": "test_work_area_type *",
      "name": "test_work_area_alloc_relative",
      "args": "const char *prefix, const char *test_path"
    },
    {
      "ret": "void",
      "name": "test_work_area_free",
      "args": "test_work_area_type *work_area"
    },
    {
      "ret": "const char *",
      "name": "test_work_area_get_cwd",
      "args": "const test_work_area_type *work_area"
    },
    {
      "ret": "const char *",
      "name": "test_work_area_get_original_cwd",
      "args": "const test_work_area_type *work_area"
    },
    {
      "ret": "void",
      "name": "test_work_area_install_file",
      "args": "const test_work_area_type *work_area, const char *input_src_file"
    },
    {
      "ret": "void",
      "name": "test_work_area_copy_directory",
      "args": "const test_work_area_type *work_area, const char *input_directory"
    },
    {
      "ret": "void",
      "name": "test_work_area_copy_directory_content",
      "args": "const test_work_area_type *work_area, const char *input_directory"
    },
    {
      "ret": "void",
      "name": "test_work_area_copy_file",
      "args": "const test_work_area_type *work_area, const char *input_file"
    },
    {
      "ret": "bool",
      "name": "test_work_area_copy_parent_directory",
      "args": "const test_work_area_type *work_area, const char *input_path"
    },
    {
      "ret": "bool",
      "name": "test_work_area_copy_parent_content",
      "args": "const test_work_area_type *work_area, const char *input_path"
    }
  ],
  "ert\\util\\type_macros.hpp": [
    {
      "ret": "#define",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "type) bool type##_is_instance(const void *__arg"
    },
    {
      "ret": "type##_type *type##",
      "name": "_safe_cast",
      "args": "void *__arg) {                               \\ if (__arg == NULL) {                                                   \\ util_abort(                                                        \\ \"%s: runtime cast failed - tried to dereference NULL\\n\",       \\ __func__);                                                     \\ return NULL;                                                       \\ }                                                                      \\ {                                                                      \\ type##_type *arg = (type##_type *)__arg;                           \\ if (arg->__type_id == TYPE_ID)                                     \\ return arg;                                                    \\ else {                                                             \\ util_abort(                                                    \\ \"%s: runtime cast failed: Got ID:%d  Expected ID:%d \\n\",   \\ __func__, arg->__type_id, TYPE_ID);                        \\ return NULL;                                                   \\ }                                                                  \\ }                                                                      \\ } #define UTIL_SAFE_CAST_HEADER(type) type##_type *type##_safe_cast(void *__arg"
    },
    {
      "ret": "const type##_type *type##",
      "name": "_safe_cast_const",
      "args": "const void *__arg) {             \\ if (__arg == NULL) {                                                   \\ util_abort(                                                        \\ \"%s: runtime cast failed - tried to dereference NULL\\n\",       \\ __func__);                                                     \\ return NULL;                                                       \\ }                                                                      \\ {                                                                      \\ const type##_type *arg = (const type##_type *)__arg;               \\ if (arg->__type_id == TYPE_ID)                                     \\ return arg;                                                    \\ else {                                                             \\ util_abort(                                                    \\ \"%s: runtime cast failed: Got ID:%d  Expected ID:%d \\n\",   \\ __func__, arg->__type_id, TYPE_ID);                        \\ return NULL;                                                   \\ }                                                                  \\ }                                                                      \\ } #define UTIL_SAFE_CAST_HEADER_CONST(type)                                      \\ const type##_type *type##_safe_cast_const(const void *__arg"
    },
    {
      "ret": "type##_type *type##",
      "name": "_try_cast",
      "args": "void *__arg) {                                \\ if (__arg == NULL)                                                     \\ return NULL;                                                       \\ {                                                                      \\ type##_type *arg = (type##_type *)__arg;                           \\ if (arg->__type_id == TYPE_ID)                                     \\ return arg;                                                    \\ else                                                               \\ return NULL;                                                   \\ }                                                                      \\ } #define UTIL_TRY_CAST_HEADER(type) type##_type *type##_try_cast(void *__arg"
    },
    {
      "ret": "const type##_type *type##",
      "name": "_try_cast_const",
      "args": "const void *__arg) {              \\ if (__arg == NULL)                                                     \\ return NULL;                                                       \\ {                                                                      \\ const type##_type *arg = (type##_type *)__arg;                     \\ if (arg->__type_id == TYPE_ID)                                     \\ return arg;                                                    \\ else                                                               \\ return NULL;                                                   \\ }                                                                      \\ } #define UTIL_TRY_CAST_HEADER_CONST(type)                                       \\ const type##_type *type##_try_cast_const(const void *__arg"
    }
  ],
  "ert\\util\\type_vector_functions.hpp": [
    {
      "ret": "int_vector_type *",
      "name": "bool_vector_alloc_active_list",
      "args": "const bool_vector_type *mask"
    },
    {
      "ret": "bool_vector_type *",
      "name": "int_vector_alloc_mask",
      "args": "const int_vector_type *active_list"
    },
    {
      "ret": "bool",
      "name": "double_vector_approx_equal",
      "args": "const double_vector_type *v1, const double_vector_type *v12, double epsilon"
    }
  ],
  "ert\\util\\util.hpp": [
    {
      "ret": "char *",
      "name": "util_get_timezone",
      "args": "void"
    },
    {
      "ret": "time_t",
      "name": "util_make_datetime_utc",
      "args": "int, int, int, int, int, int"
    },
    {
      "ret": "time_t",
      "name": "util_make_date_utc",
      "args": "int, int, int"
    },
    {
      "ret": "void",
      "name": "util_inplace_forward_seconds_utc",
      "args": "time_t *t, double seconds"
    },
    {
      "ret": "void",
      "name": "util_inplace_forward_days_utc",
      "args": "time_t *t, double days"
    },
    {
      "ret": "double",
      "name": "util_difftime",
      "args": "time_t, time_t, int *, int *, int *, int *"
    },
    {
      "ret": "double",
      "name": "util_difftime_days",
      "args": "time_t, time_t"
    },
    {
      "ret": "double",
      "name": "util_difftime_seconds",
      "args": "time_t start_time, time_t end_time"
    },
    {
      "ret": "char *",
      "name": "util_alloc_sprintf_va",
      "args": "const char *fmt, va_list ap"
    },
    {
      "ret": "bool",
      "name": "util_sscanf_isodate",
      "args": "const char *, time_t *"
    },
    {
      "ret": "bool",
      "name": "util_entry_exists",
      "args": "const char *entry"
    },
    {
      "ret": "bool",
      "name": "util_file_exists",
      "args": "const char *"
    },
    {
      "ret": "bool",
      "name": "util_is_abs_path",
      "args": "const char *"
    },
    {
      "ret": "char *",
      "name": "util_alloc_abs_path",
      "args": "const char *path"
    },
    {
      "ret": "char *",
      "name": "util_alloc_rel_path",
      "args": "const char *__root_path, const char *path"
    },
    {
      "ret": "bool",
      "name": "util_fmt_bit8",
      "args": "const char *"
    },
    {
      "ret": "bool",
      "name": "util_mkdir_p",
      "args": "const char *"
    },
    {
      "ret": "void",
      "name": "util_make_path",
      "args": "const char *"
    },
    {
      "ret": "double",
      "name": "util_file_difftime",
      "args": "const char *, const char *"
    },
    {
      "ret": "size_t",
      "name": "util_file_size",
      "args": "const char *"
    },
    {
      "ret": "size_t",
      "name": "util_fd_size",
      "args": "int fd"
    },
    {
      "ret": "void",
      "name": "util_clear_directory",
      "args": "const char *path, bool strict_uid, bool unlink_root"
    },
    {
      "ret": "void",
      "name": "util_strupr",
      "args": "char *"
    },
    {
      "ret": "bool",
      "name": "util_string_equal",
      "args": "const char *s1, const char *s2"
    },
    {
      "ret": "char *",
      "name": "util_alloc_strupr_copy",
      "args": "const char *"
    },
    {
      "ret": "bool",
      "name": "util_copy_file",
      "args": "const char *, const char *"
    },
    {
      "ret": "bool",
      "name": "util_copy_file__",
      "args": "const char *src_file, const char *target_file, size_t buffer_size, void *buffer, bool abort_on_error"
    },
    {
      "ret": "char *",
      "name": "util_alloc_cwd",
      "args": "void"
    },
    {
      "ret": "bool",
      "name": "util_is_cwd",
      "args": "const char *path"
    },
    {
      "ret": "char *",
      "name": "util_alloc_normal_path",
      "args": "const char *input_path"
    },
    {
      "ret": "char *",
      "name": "util_alloc_realpath",
      "args": "const char *"
    },
    {
      "ret": "char *",
      "name": "util_alloc_realpath__",
      "args": "const char *input_path"
    },
    {
      "ret": "bool",
      "name": "util_ftruncate",
      "args": "FILE *stream, long size"
    },
    {
      "ret": "int",
      "name": "util_roundf",
      "args": "float x"
    },
    {
      "ret": "int",
      "name": "util_round",
      "args": "double x"
    },
    {
      "ret": "offset_type",
      "name": "util_ftell",
      "args": "FILE *stream"
    },
    {
      "ret": "int",
      "name": "util_fseek",
      "args": "FILE *stream, offset_type offset, int whence"
    },
    {
      "ret": "void",
      "name": "util_rewind",
      "args": "FILE *stream"
    },
    {
      "ret": "int",
      "name": "util_stat",
      "args": "const char *filename, stat_type *stat_info"
    },
    {
      "ret": "int",
      "name": "util_fstat",
      "args": "int fileno, stat_type *stat_info"
    },
    {
      "ret": "void",
      "name": "util_copy_directory_content",
      "args": "const char *src_path, const char *target_path"
    },
    {
      "ret": "void",
      "name": "util_copy_directory",
      "args": "const char *, const char *"
    },
    {
      "ret": "int",
      "name": "util_forward_line",
      "args": "FILE *, bool *"
    },
    {
      "ret": "void",
      "name": "util_rewind_line",
      "args": "FILE *"
    },
    {
      "ret": "FILE *",
      "name": "util_mkdir_fopen",
      "args": "const char *filename, const char *mode"
    },
    {
      "ret": "FILE *",
      "name": "util_fopen",
      "args": "const char *, const char *"
    },
    {
      "ret": "FILE *",
      "name": "util_fopen__",
      "args": "const char *filename, const char *mode"
    },
    {
      "ret": "bool",
      "name": "util_fopen_test",
      "args": "const char *, const char *"
    },
    {
      "ret": "char *",
      "name": "util_split_alloc_filename",
      "args": "const char *input_path"
    },
    {
      "ret": "void",
      "name": "util_alloc_file_components",
      "args": "const char *, char **, char **, char **"
    },
    {
      "ret": "char *",
      "name": "util_fscanf_alloc_line",
      "args": "FILE *, bool *"
    },
    {
      "ret": "bool",
      "name": "util_sscanf_bool",
      "args": "const char *, bool *"
    },
    {
      "ret": "int",
      "name": "util_strcmp_int",
      "args": "const char *s1, const char *s2"
    },
    {
      "ret": "int",
      "name": "util_strcmp_float",
      "args": "const char *s1, const char *s2"
    },
    {
      "ret": "bool",
      "name": "util_sscanf_int",
      "args": "const char *, int *"
    },
    {
      "ret": "bool",
      "name": "util_sscanf_double",
      "args": "const char *, double *"
    },
    {
      "ret": "char *",
      "name": "util_alloc_filename",
      "args": "const char *, const char *, const char *"
    },
    {
      "ret": "char *",
      "name": "util_alloc_strip_copy",
      "args": "const char *"
    },
    {
      "ret": "char *",
      "name": "util_strcat_realloc",
      "args": "char *, const char *"
    },
    {
      "ret": "char *",
      "name": "util_alloc_string_copy",
      "args": "const char *"
    },
    {
      "ret": "void",
      "name": "util_path_split",
      "args": "const char *line, int *_tokens, char ***_token_list"
    },
    {
      "ret": "char *",
      "name": "util_alloc_parent_path",
      "args": "const char *path"
    },
    {
      "ret": "void",
      "name": "util_binary_split_string",
      "args": "const char *, const char *, bool, char **, char **"
    },
    {
      "ret": "int",
      "name": "util_string_replace_inplace",
      "args": "char **, const char *, const char *"
    },
    {
      "ret": "char *",
      "name": "util_realloc_string_copy",
      "args": "char *, const char *"
    },
    {
      "ret": "void",
      "name": "util_free_stringlist",
      "args": "char **, int"
    },
    {
      "ret": "char *",
      "name": "util_alloc_substring_copy",
      "args": "const char *, int offset, int N"
    },
    {
      "ret": "bool",
      "name": "util_is_directory",
      "args": "const char *"
    },
    {
      "ret": "bool",
      "name": "util_is_file",
      "args": "const char *"
    },
    {
      "ret": "void",
      "name": "util_set_datetime_values_utc",
      "args": "time_t, int *, int *, int *, int *, int *, int *"
    },
    {
      "ret": "void",
      "name": "util_set_date_values_utc",
      "args": "time_t, int *, int *, int *"
    },
    {
      "ret": "unsigned int",
      "name": "util_clock_seed",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "util_fread_dev_random",
      "args": "int, char *"
    },
    {
      "ret": "void",
      "name": "util_fread_dev_urandom",
      "args": "int, char *"
    },
    {
      "ret": "void",
      "name": "util_abort_test_set_intercept_function",
      "args": "const char *"
    },
    {
      "ret": "void",
      "name": "util_install_signals",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "util_update_signals",
      "args": "void"
    },
    {
      "ret": "void *",
      "name": "util_realloc",
      "args": "void *, size_t"
    },
    {
      "ret": "void *",
      "name": "util_malloc",
      "args": "size_t"
    },
    {
      "ret": "void *",
      "name": "util_calloc",
      "args": "size_t elements, size_t element_size"
    },
    {
      "ret": "void *",
      "name": "util_realloc_copy",
      "args": "void *org_ptr, const void *src, size_t byte_size"
    },
    {
      "ret": "void *",
      "name": "util_alloc_copy",
      "args": "const void *, size_t"
    },
    {
      "ret": "char *",
      "name": "util_fread_alloc_file_content",
      "args": "const char *, int *"
    },
    {
      "ret": "void",
      "name": "util_fwrite_string",
      "args": "const char *, FILE *"
    },
    {
      "ret": "char *",
      "name": "util_fread_alloc_string",
      "args": "FILE *"
    },
    {
      "ret": "void",
      "name": "util_endian_flip_vector",
      "args": "void *data, int element_size, int elements"
    },
    {
      "ret": "void",
      "name": "util_double_vector_max_min",
      "args": "int, const double *, double *, double *"
    },
    {
      "ret": "void",
      "name": "util_update_double_max_min",
      "args": "double, double *, double *"
    },
    {
      "ret": "void",
      "name": "util_update_float_max_min",
      "args": "float, float *, float *"
    },
    {
      "ret": "void",
      "name": "util_update_int_max_min",
      "args": "int, int *, int *"
    },
    {
      "ret": "int",
      "name": "util_int_max",
      "args": "int, int"
    },
    {
      "ret": "double",
      "name": "util_double_max",
      "args": "double, double"
    },
    {
      "ret": "float",
      "name": "util_float_max",
      "args": "float, float"
    },
    {
      "ret": "int",
      "name": "util_int_min",
      "args": "int, int"
    },
    {
      "ret": "size_t",
      "name": "util_size_t_min",
      "args": "size_t a, size_t b"
    },
    {
      "ret": "size_t",
      "name": "util_size_t_max",
      "args": "size_t a, size_t b"
    },
    {
      "ret": "double",
      "name": "util_double_min",
      "args": "double, double"
    },
    {
      "ret": "float",
      "name": "util_float_min",
      "args": "float, float"
    },
    {
      "ret": "void",
      "name": "util_fskip_lines",
      "args": "FILE *, int"
    },
    {
      "ret": "bool",
      "name": "util_same_file",
      "args": "const char *, const char *"
    },
    {
      "ret": "void",
      "name": "util_fread",
      "args": "void *, size_t, size_t, FILE *, const char *"
    },
    {
      "ret": "void",
      "name": "util_fwrite",
      "args": "const void *, size_t, size_t, FILE *, const char *"
    },
    {
      "ret": "int",
      "name": "util_fread_int",
      "args": "FILE *"
    },
    {
      "ret": "void",
      "name": "util_fwrite_offset",
      "args": "offset_type, FILE *"
    },
    {
      "ret": "void",
      "name": "util_fwrite_size_t",
      "args": "size_t, FILE *"
    },
    {
      "ret": "void",
      "name": "util_fwrite_int",
      "args": "int, FILE *"
    },
    {
      "ret": "int",
      "name": "util_get_current_linenr",
      "args": "FILE *stream"
    },
    {
      "ret": "bool",
      "name": "util_fseek_string",
      "args": "FILE *stream, const char *string, bool skip_string, bool case_sensitive"
    },
    {
      "ret": "bool",
      "name": "util_files_equal",
      "args": "const char *file1, const char *file2"
    },
    {
      "ret": "double",
      "name": "util_kahan_sum",
      "args": "const double *data, size_t N"
    },
    {
      "ret": "bool",
      "name": "util_double_approx_equal",
      "args": "double d1, double d2"
    },
    {
      "ret": "bool",
      "name": "util_double_approx_equal__",
      "args": "double d1, double d2, double rel_eps, double abs_eps"
    },
    {
      "ret": "bool",
      "name": "util_float_approx_equal__",
      "args": "float d1, float d2, float rel_eps, float abs_eps"
    },
    {
      "ret": "int",
      "name": "util_fnmatch",
      "args": "const char *pattern, const char *string"
    },
    {
      "ret": "void",
      "name": "util_time_utc",
      "args": "time_t *t, struct tm *ts"
    },
    {
      "ret": "bool",
      "name": "util_is_link",
      "args": "const char *); // Will always return false on windows int util_chdir(const char *path"
    },
    {
      "ret": "bool",
      "name": "util_access",
      "args": "const char *entry, mode_t mode"
    },
    {
      "ret": "bool",
      "name": "util_access",
      "args": "const char *entry, int mode"
    },
    {
      "ret": "int util_sorted_contains_##",
      "name": "TYPE",
      "args": "const TYPE *data, int size, TYPE value) CONTAINS_HEADER(int"
    },
    {
      "ret": "",
      "name": "CONTAINS_HEADER",
      "args": "time_t"
    },
    {
      "ret": "",
      "name": "CONTAINS_HEADER",
      "args": "size_t"
    },
    {
      "ret": "void",
      "name": "util_set_abort_handler",
      "args": "util_abort_handler_t *"
    },
    {
      "ret": "void",
      "name": "util_abort_signal",
      "args": "int"
    }
  ],
  "ert\\util\\util_unlink.hpp": [
    {
      "ret": "int",
      "name": "util_unlink",
      "args": "const char *filename"
    }
  ],
  "ert\\util\\vector.hpp": [
    {
      "ret": "vector_type *",
      "name": "vector_alloc_new",
      "args": "void"
    },
    {
      "ret": "int",
      "name": "vector_append_ref",
      "args": "vector_type *, const void *"
    },
    {
      "ret": "int",
      "name": "vector_append_owned_ref",
      "args": "vector_type *, const void *, free_ftype *del"
    },
    {
      "ret": "void",
      "name": "vector_iset_ref",
      "args": "vector_type *, int, const void *"
    },
    {
      "ret": "void",
      "name": "vector_iset_owned_ref",
      "args": "vector_type *, int, const void *, free_ftype *del"
    },
    {
      "ret": "void",
      "name": "vector_clear",
      "args": "vector_type *vector"
    },
    {
      "ret": "void",
      "name": "vector_free",
      "args": "vector_type *"
    },
    {
      "ret": "void",
      "name": "vector_free__",
      "args": "void *arg"
    },
    {
      "ret": "void",
      "name": "vector_append_buffer",
      "args": "vector_type *, const void *, int"
    },
    {
      "ret": "void *",
      "name": "vector_safe_iget",
      "args": "const vector_type *vector, int index"
    },
    {
      "ret": "const void *",
      "name": "vector_iget_const",
      "args": "const vector_type *, int"
    },
    {
      "ret": "void *",
      "name": "vector_iget",
      "args": "const vector_type *, int"
    },
    {
      "ret": "void",
      "name": "vector_idel",
      "args": "vector_type *vector, int index"
    },
    {
      "ret": "void",
      "name": "vector_shrink",
      "args": "vector_type *vector, int new_size"
    },
    {
      "ret": "void *",
      "name": "vector_get_last",
      "args": "const vector_type *"
    },
    {
      "ret": "int",
      "name": "vector_get_size",
      "args": "const vector_type *"
    },
    {
      "ret": "void *",
      "name": "vector_pop_back",
      "args": "vector_type *"
    },
    {
      "ret": "void",
      "name": "vector_sort",
      "args": "vector_type *vector, vector_cmp_ftype *cmp"
    },
    {
      "ret": "int_vector_type *",
      "name": "vector_alloc_sort_perm",
      "args": "const vector_type *vector, vector_cmp_ftype *cmp"
    },
    {
      "ret": "void",
      "name": "vector_permute",
      "args": "vector_type *vector, const int_vector_type *perm_vector"
    },
    {
      "ret": "void",
      "name": "vector_inplace_reverse",
      "args": "vector_type *vector"
    },
    {
      "ret": "vector_type *",
      "name": "vector_alloc_copy",
      "args": "const vector_type *src, bool deep_copy"
    },
    {
      "ret": "void",
      "name": "vector_iset_buffer",
      "args": "vector_type *vector, int index, const void *buffer, int buffer_size"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "vector"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "vector"
    }
  ],
  "resdata\\fault_block.hpp": [
    {
      "ret": "void",
      "name": "fault_block_free__",
      "args": "void *arg"
    },
    {
      "ret": "int",
      "name": "fault_block_get_size",
      "args": "const fault_block_type *block"
    },
    {
      "ret": "double",
      "name": "fault_block_get_xc",
      "args": "fault_block_type *fault_block"
    },
    {
      "ret": "double",
      "name": "fault_block_get_yc",
      "args": "fault_block_type *fault_block"
    },
    {
      "ret": "int",
      "name": "fault_block_get_id",
      "args": "const fault_block_type *block"
    },
    {
      "ret": "void",
      "name": "fault_block_export_cell",
      "args": "const fault_block_type *fault_block, int index, int *i, int *j, int *k, double *x, double *y, double *z"
    },
    {
      "ret": "void",
      "name": "fault_block_assign_to_region",
      "args": "fault_block_type *fault_block, int region_id"
    },
    {
      "ret": "const int_vector_type *",
      "name": "fault_block_get_region_list",
      "args": "const fault_block_type *fault_block"
    },
    {
      "ret": "void",
      "name": "fault_block_add_cell",
      "args": "fault_block_type *fault_block, int i, int j"
    },
    {
      "ret": "bool",
      "name": "fault_block_trace_edge",
      "args": "const fault_block_type *block, double_vector_type *x_list, double_vector_type *y_list, int_vector_type *cell_list"
    },
    {
      "ret": "const int_vector_type *",
      "name": "fault_block_get_global_index_list",
      "args": "const fault_block_type *fault_block"
    },
    {
      "ret": "void",
      "name": "fault_block_copy_content",
      "args": "fault_block_type *target_block, const fault_block_type *src_block"
    },
    {
      "ret": "void",
      "name": "fault_block_list_neighbours",
      "args": "const fault_block_type *block, bool connected_only, const geo_polygon_collection_type *polylines, int_vector_type *neighbour_list"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "fault_block"
    }
  ],
  "resdata\\fault_block_layer.hpp": [
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "fault_block_layer"
    },
    {
      "ret": "fault_block_layer_type *",
      "name": "fault_block_layer_alloc",
      "args": "const rd_grid_type *grid, int k"
    },
    {
      "ret": "void",
      "name": "fault_block_layer_free",
      "args": "fault_block_layer_type *layer"
    },
    {
      "ret": "bool",
      "name": "fault_block_layer_has_block",
      "args": "const fault_block_layer_type *layer, int block_id"
    },
    {
      "ret": "void",
      "name": "fault_block_layer_del_block",
      "args": "fault_block_layer_type *layer, int block_id"
    },
    {
      "ret": "fault_block_type *",
      "name": "fault_block_layer_add_block",
      "args": "fault_block_layer_type *layer, int block_id"
    },
    {
      "ret": "fault_block_type *",
      "name": "fault_block_layer_get_block",
      "args": "const fault_block_layer_type *layer, int block_id"
    },
    {
      "ret": "fault_block_type *",
      "name": "fault_block_layer_iget_block",
      "args": "const fault_block_layer_type *layer, int storage_index"
    },
    {
      "ret": "fault_block_type *",
      "name": "fault_block_layer_safe_get_block",
      "args": "fault_block_layer_type *layer, int block_id"
    },
    {
      "ret": "int",
      "name": "fault_block_layer_get_max_id",
      "args": "const fault_block_layer_type *layer"
    },
    {
      "ret": "int",
      "name": "fault_block_layer_get_next_id",
      "args": "const fault_block_layer_type *layer"
    },
    {
      "ret": "int",
      "name": "fault_block_layer_get_size",
      "args": "const fault_block_layer_type *layer"
    },
    {
      "ret": "bool",
      "name": "fault_block_layer_scan_kw",
      "args": "fault_block_layer_type *layer, const rd_kw_type *fault_block_kw"
    },
    {
      "ret": "bool",
      "name": "fault_block_layer_load_kw",
      "args": "fault_block_layer_type *layer, const rd_kw_type *fault_block_kw"
    },
    {
      "ret": "int",
      "name": "fault_block_layer_get_k",
      "args": "const fault_block_layer_type *layer"
    },
    {
      "ret": "void",
      "name": "fault_block_layer_scan_layer",
      "args": "fault_block_layer_type *fault_layer, layer_type *layer"
    },
    {
      "ret": "void",
      "name": "fault_block_layer_insert_block_content",
      "args": "fault_block_layer_type *layer, const fault_block_type *src_block"
    },
    {
      "ret": "bool",
      "name": "fault_block_layer_export",
      "args": "const fault_block_layer_type *layer, rd_kw_type *faultblock_kw"
    },
    {
      "ret": "const rd_grid_type *",
      "name": "fault_block_layer_get_grid",
      "args": "const fault_block_layer_type *layer"
    },
    {
      "ret": "layer_type *",
      "name": "fault_block_layer_get_layer",
      "args": "const fault_block_layer_type *layer"
    }
  ],
  "resdata\\layer.hpp": [
    {
      "ret": "bool",
      "name": "layer_iget_left_barrier",
      "args": "const layer_type *layer, int i, int j"
    },
    {
      "ret": "bool",
      "name": "layer_iget_bottom_barrier",
      "args": "const layer_type *layer, int i, int j"
    },
    {
      "ret": "int",
      "name": "layer_get_nx",
      "args": "const layer_type *layer"
    },
    {
      "ret": "int",
      "name": "layer_get_ny",
      "args": "const layer_type *layer"
    },
    {
      "ret": "layer_type *",
      "name": "layer_alloc",
      "args": "int nx, int ny"
    },
    {
      "ret": "void",
      "name": "layer_free",
      "args": "layer_type *layer"
    },
    {
      "ret": "int",
      "name": "layer_replace_cell_values",
      "args": "layer_type *layer, int old_value, int new_value"
    },
    {
      "ret": "bool",
      "name": "layer_iget_active",
      "args": "const layer_type *layer, int i, int j"
    },
    {
      "ret": "int",
      "name": "layer_iget_cell_value",
      "args": "const layer_type *layer, int i, int j"
    },
    {
      "ret": "void",
      "name": "layer_iset_cell_value",
      "args": "layer_type *layer, int i, int j, int value"
    },
    {
      "ret": "int",
      "name": "layer_iget_edge_value",
      "args": "const layer_type *layer, int i, int j, edge_dir_enum dir"
    },
    {
      "ret": "bool",
      "name": "layer_cell_on_edge",
      "args": "const layer_type *layer, int i, int j"
    },
    {
      "ret": "int",
      "name": "layer_get_cell_sum",
      "args": "const layer_type *layer"
    },
    {
      "ret": "bool",
      "name": "layer_trace_block_content",
      "args": "layer_type *layer, bool erase, int start_i, int start_j, int value, int_vector_type *i_list, int_vector_type *j_list"
    },
    {
      "ret": "bool",
      "name": "layer_cell_contact",
      "args": "const layer_type *layer, int i1, int j1, int i2, int j2"
    },
    {
      "ret": "void",
      "name": "layer_add_interp_barrier",
      "args": "layer_type *layer, int c1, int c2"
    },
    {
      "ret": "void",
      "name": "layer_add_ijbarrier",
      "args": "layer_type *layer, int i1, int j1, int i2, int j2"
    },
    {
      "ret": "void",
      "name": "layer_add_barrier",
      "args": "layer_type *layer, int c1, int c2"
    },
    {
      "ret": "void",
      "name": "layer_memcpy",
      "args": "layer_type *target_layer, const layer_type *src_layer"
    },
    {
      "ret": "void",
      "name": "layer_update_active",
      "args": "layer_type *layer, const rd_grid_type *grid, int k"
    },
    {
      "ret": "void",
      "name": "layer_clear_cells",
      "args": "layer_type *layer"
    },
    {
      "ret": "void",
      "name": "layer_update_connected_cells",
      "args": "layer_type *layer, int i, int j, int org_value, int new_value"
    },
    {
      "ret": "void",
      "name": "layer_assign",
      "args": "layer_type *layer, int value"
    },
    {
      "ret": "void",
      "name": "layer_cells_equal",
      "args": "const layer_type *layer, int value, int_vector_type *i_list, int_vector_type *j_list"
    },
    {
      "ret": "int",
      "name": "layer_count_equal",
      "args": "const layer_type *layer, int value"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "layer"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "layer"
    }
  ],
  "resdata\\nnc_info.hpp": [
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "nnc_info"
    },
    {
      "ret": "nnc_info_type *",
      "name": "nnc_info_alloc",
      "args": "int lgr_nr"
    },
    {
      "ret": "void",
      "name": "nnc_info_free",
      "args": "nnc_info_type *nnc_info"
    },
    {
      "ret": "void",
      "name": "nnc_info_add_nnc",
      "args": "nnc_info_type *nnc_info, int lgr_nr, int global_cell_number, int nnc_index"
    },
    {
      "ret": "nnc_vector_type *",
      "name": "nnc_info_iget_vector",
      "args": "const nnc_info_type *nnc_info, int lgr_index"
    },
    {
      "ret": "nnc_vector_type *",
      "name": "nnc_info_get_vector",
      "args": "const nnc_info_type *nnc_info, int lgr_nr"
    },
    {
      "ret": "nnc_vector_type *",
      "name": "nnc_info_get_self_vector",
      "args": "const nnc_info_type *nnc_info"
    },
    {
      "ret": "int",
      "name": "nnc_info_get_lgr_nr",
      "args": "const nnc_info_type *nnc_info"
    },
    {
      "ret": "int",
      "name": "nnc_info_get_size",
      "args": "const nnc_info_type *nnc_info"
    },
    {
      "ret": "int",
      "name": "nnc_info_get_total_size",
      "args": "const nnc_info_type *nnc_info"
    },
    {
      "ret": "bool",
      "name": "nnc_info_equal",
      "args": "const nnc_info_type *nnc_info1, const nnc_info_type *nnc_info2"
    },
    {
      "ret": "nnc_info_type *",
      "name": "nnc_info_alloc_copy",
      "args": "const nnc_info_type *src_info"
    },
    {
      "ret": "bool",
      "name": "nnc_info_has_grid_index_list",
      "args": "const nnc_info_type *nnc_info, int lgr_nr"
    }
  ],
  "resdata\\nnc_vector.hpp": [
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "nnc_vector"
    },
    {
      "ret": "int",
      "name": "nnc_vector_iget_nnc_index",
      "args": "const nnc_vector_type *nnc_vector, int index"
    },
    {
      "ret": "int",
      "name": "nnc_vector_iget_grid_index",
      "args": "const nnc_vector_type *nnc_vector, int index"
    },
    {
      "ret": "nnc_vector_type *",
      "name": "nnc_vector_alloc",
      "args": "int lgr_nr"
    },
    {
      "ret": "nnc_vector_type *",
      "name": "nnc_vector_alloc_copy",
      "args": "const nnc_vector_type *src_vector"
    },
    {
      "ret": "void",
      "name": "nnc_vector_free",
      "args": "nnc_vector_type *nnc_vector"
    },
    {
      "ret": "void",
      "name": "nnc_vector_add_nnc",
      "args": "nnc_vector_type *nnc_vector, int global_cell_number, int nnc_index"
    },
    {
      "ret": "int",
      "name": "nnc_vector_get_lgr_nr",
      "args": "const nnc_vector_type *nnc_vector"
    },
    {
      "ret": "void",
      "name": "nnc_vector_free__",
      "args": "void *arg"
    },
    {
      "ret": "int",
      "name": "nnc_vector_get_size",
      "args": "const nnc_vector_type *nnc_vector"
    },
    {
      "ret": "bool",
      "name": "nnc_vector_equal",
      "args": "const nnc_vector_type *nnc_vector1, const nnc_vector_type *nnc_vector2"
    }
  ],
  "resdata\\rd_coarse_cell.hpp": [
    {
      "ret": "bool",
      "name": "rd_coarse_cell_equal",
      "args": "const rd_coarse_cell_type *coarse_cell1, const rd_coarse_cell_type *coarse_cell2"
    },
    {
      "ret": "rd_coarse_cell_type *",
      "name": "rd_coarse_cell_alloc",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "rd_coarse_cell_update",
      "args": "rd_coarse_cell_type *coarse_cell, int i, int j, int k, int global_index"
    },
    {
      "ret": "void",
      "name": "rd_coarse_cell_free",
      "args": "rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "void",
      "name": "rd_coarse_cell_free__",
      "args": "void *arg"
    },
    {
      "ret": "const int *",
      "name": "rd_coarse_cell_get_box_ptr",
      "args": "const rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "int",
      "name": "rd_coarse_cell_get_size",
      "args": "const rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "const int *",
      "name": "rd_coarse_cell_get_index_ptr",
      "args": "rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "const int_vector_type *",
      "name": "rd_coarse_cell_get_index_vector",
      "args": "rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "void",
      "name": "rd_coarse_cell_reset_active_index",
      "args": "rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "void",
      "name": "rd_coarse_cell_update_index",
      "args": "rd_coarse_cell_type *coarse_cell, int global_index, int *active_index, int *active_fracture_index, int active_value"
    },
    {
      "ret": "int",
      "name": "rd_coarse_cell_get_active_index",
      "args": "const rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "int",
      "name": "rd_coarse_cell_get_active_fracture_index",
      "args": "const rd_coarse_cell_type *coarse_cell"
    },
    {
      "ret": "int",
      "name": "rd_coarse_cell_iget_active_cell_index",
      "args": "const rd_coarse_cell_type *coarse_cell, int index"
    },
    {
      "ret": "int",
      "name": "rd_coarse_cell_iget_active_value",
      "args": "const rd_coarse_cell_type *coarse_cell, int index"
    },
    {
      "ret": "int",
      "name": "rd_coarse_cell_get_num_active",
      "args": "const rd_coarse_cell_type *coarse_cell"
    }
  ],
  "resdata\\rd_file.hpp": [
    {
      "ret": "bool",
      "name": "rd_file_load_all",
      "args": "rd_file_type *rd_file"
    },
    {
      "ret": "rd_file_type *",
      "name": "rd_file_open",
      "args": "const char *filename, int flags"
    },
    {
      "ret": "rd_file_type *",
      "name": "rd_file_fast_open",
      "args": "const char *filename, const char *index_filename, int flags"
    },
    {
      "ret": "bool",
      "name": "rd_file_write_index",
      "args": "const rd_file_type *rd_file, const char *index_filename"
    },
    {
      "ret": "bool",
      "name": "rd_file_index_valid",
      "args": "const char *file_name, const char *index_file_name"
    },
    {
      "ret": "void",
      "name": "rd_file_close",
      "args": "rd_file_type *rd_file"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_file_icopy_kw",
      "args": "const rd_file_type *rd_file, int index"
    },
    {
      "ret": "bool",
      "name": "rd_file_has_kw",
      "args": "const rd_file_type *rd_file, const char *kw"
    },
    {
      "ret": "int",
      "name": "rd_file_get_num_named_kw",
      "args": "const rd_file_type *rd_file, const char *kw"
    },
    {
      "ret": "int",
      "name": "rd_file_get_size",
      "args": "const rd_file_type *rd_file"
    },
    {
      "ret": "const char *",
      "name": "rd_file_get_src_file",
      "args": "const rd_file_type *rd_file"
    },
    {
      "ret": "rd_version_enum",
      "name": "rd_file_get_rd_version",
      "args": "const rd_file_type *file"
    },
    {
      "ret": "void",
      "name": "rd_file_fwrite_fortio",
      "args": "const rd_file_type *ec_file, fortio_type *fortio, int offset"
    },
    {
      "ret": "int",
      "name": "rd_file_get_phases",
      "args": "const rd_file_type *init_file"
    },
    {
      "ret": "bool",
      "name": "rd_file_writable",
      "args": "const rd_file_type *rd_file"
    },
    {
      "ret": "bool",
      "name": "rd_file_flags_set",
      "args": "const rd_file_type *rd_file, int flags"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_file_iget_kw",
      "args": "const rd_file_type *file, int global_index"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_file_iget_named_kw",
      "args": "const rd_file_type *file, const char *kw, int ith"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_get_global_blockview",
      "args": "rd_file_type *rd_file, const char *kw, int occurence"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_alloc_global_blockview",
      "args": "rd_file_type *rd_file, const char *kw, int occurence"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_get_global_view",
      "args": "rd_file_type *rd_file"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_get_active_view",
      "args": "rd_file_type *rd_file"
    },
    {
      "ret": "bool",
      "name": "rd_file_save_kw",
      "args": "const rd_file_type *rd_file, const rd_kw_type *rd_kw"
    },
    {
      "ret": "double",
      "name": "rd_file_iget_restart_sim_days",
      "args": "const rd_file_type *restart_file, int index"
    },
    {
      "ret": "time_t",
      "name": "rd_file_iget_restart_sim_date",
      "args": "const rd_file_type *restart_file, int occurence"
    },
    {
      "ret": "int",
      "name": "rd_file_get_restart_index",
      "args": "const rd_file_type *restart_file, time_t sim_time"
    },
    {
      "ret": "bool",
      "name": "rd_file_has_report_step",
      "args": "const rd_file_type *rd_file, int report_step"
    },
    {
      "ret": "bool",
      "name": "rd_file_has_sim_time",
      "args": "const rd_file_type *rd_file, time_t sim_time"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_get_restart_view",
      "args": "rd_file_type *rd_file, int input_index, int report_step, time_t sim_time, double sim_days"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_get_summary_view",
      "args": "rd_file_type *rd_file, int report_step"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "rd_file"
    },
    {
      "ret": "bool",
      "name": "rd_file_subselect_block",
      "args": "rd_file_type *rd_file, const char *kw, int occurence"
    }
  ],
  "resdata\\rd_file_kw.hpp": [
    {
      "ret": "inv_map_type *",
      "name": "inv_map_alloc",
      "args": "void"
    },
    {
      "ret": "rd_file_kw_type *",
      "name": "inv_map_get_file_kw",
      "args": "inv_map_type *inv_map, const rd_kw_type *rd_kw"
    },
    {
      "ret": "void",
      "name": "inv_map_free",
      "args": "inv_map_type *map"
    },
    {
      "ret": "bool",
      "name": "rd_file_kw_equal",
      "args": "const rd_file_kw_type *kw1, const rd_file_kw_type *kw2"
    },
    {
      "ret": "rd_file_kw_type *",
      "name": "rd_file_kw_alloc",
      "args": "const rd_kw_type *rd_kw, offset_type offset"
    },
    {
      "ret": "rd_file_kw_type *",
      "name": "rd_file_kw_alloc0",
      "args": "const char *header, rd_data_type data_type, int size, offset_type offset"
    },
    {
      "ret": "void",
      "name": "rd_file_kw_free",
      "args": "rd_file_kw_type *file_kw"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_file_kw_get_kw",
      "args": "rd_file_kw_type *file_kw, fortio_type *fortio, inv_map_type *inv_map"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_file_kw_get_kw_ptr",
      "args": "rd_file_kw_type *file_kw"
    },
    {
      "ret": "const char *",
      "name": "rd_file_kw_get_header",
      "args": "const rd_file_kw_type *file_kw"
    },
    {
      "ret": "int",
      "name": "rd_file_kw_get_size",
      "args": "const rd_file_kw_type *file_kw"
    },
    {
      "ret": "rd_data_type",
      "name": "rd_file_kw_get_data_type",
      "args": "const rd_file_kw_type *"
    },
    {
      "ret": "offset_type",
      "name": "rd_file_kw_get_offset",
      "args": "const rd_file_kw_type *file_kw"
    },
    {
      "ret": "bool",
      "name": "rd_file_kw_fskip_data",
      "args": "const rd_file_kw_type *file_kw, fortio_type *fortio"
    },
    {
      "ret": "void",
      "name": "rd_file_kw_inplace_fwrite",
      "args": "rd_file_kw_type *file_kw, fortio_type *fortio"
    },
    {
      "ret": "void",
      "name": "rd_file_kw_fwrite",
      "args": "const rd_file_kw_type *file_kw, FILE *stream"
    },
    {
      "ret": "rd_file_kw_type **",
      "name": "rd_file_kw_fread_alloc_multiple",
      "args": "FILE *stream, int num"
    },
    {
      "ret": "rd_file_kw_type *",
      "name": "rd_file_kw_fread_alloc",
      "args": "FILE *stream"
    },
    {
      "ret": "void",
      "name": "rd_file_kw_start_transaction",
      "args": "const rd_file_kw_type *file_kw, int *ref_count"
    },
    {
      "ret": "void",
      "name": "rd_file_kw_end_transaction",
      "args": "rd_file_kw_type *file_kw, int ref_count"
    }
  ],
  "resdata\\rd_file_view.hpp": [
    {
      "ret": "bool",
      "name": "rd_file_view_flags_set",
      "args": "const rd_file_view_type *file_view, int query_flags"
    },
    {
      "ret": "bool",
      "name": "rd_file_view_check_flags",
      "args": "int state_flags, int query_flags"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_view_alloc",
      "args": "fortio_type *fortio, int *flags, inv_map_type *inv_map, bool owner"
    },
    {
      "ret": "void",
      "name": "rd_file_view_make_index",
      "args": "rd_file_view_type *rd_file_view"
    },
    {
      "ret": "bool",
      "name": "rd_file_view_has_kw",
      "args": "const rd_file_view_type *rd_file_view, const char *kw"
    },
    {
      "ret": "rd_file_kw_type *",
      "name": "rd_file_view_iget_file_kw",
      "args": "const rd_file_view_type *rd_file_view, int global_index"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_file_view_iget_kw",
      "args": "const rd_file_view_type *rd_file_view, int index"
    },
    {
      "ret": "void",
      "name": "rd_file_view_index_fload_kw",
      "args": "const rd_file_view_type *rd_file_view, const char *kw, int index, const int_vector_type *index_map, char *buffer"
    },
    {
      "ret": "const char *",
      "name": "rd_file_view_iget_distinct_kw",
      "args": "const rd_file_view_type *rd_file_view, int index"
    },
    {
      "ret": "int",
      "name": "rd_file_view_get_num_distinct_kw",
      "args": "const rd_file_view_type *rd_file_view"
    },
    {
      "ret": "int",
      "name": "rd_file_view_get_size",
      "args": "const rd_file_view_type *rd_file_view"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_file_view_iget_named_kw",
      "args": "const rd_file_view_type *rd_file_view, const char *kw, int ith"
    },
    {
      "ret": "bool",
      "name": "rd_file_view_load_all",
      "args": "rd_file_view_type *rd_file_view"
    },
    {
      "ret": "void",
      "name": "rd_file_view_add_kw",
      "args": "rd_file_view_type *rd_file_view, rd_file_kw_type *file_kw"
    },
    {
      "ret": "void",
      "name": "rd_file_view_free",
      "args": "rd_file_view_type *rd_file_view"
    },
    {
      "ret": "int",
      "name": "rd_file_view_get_num_named_kw",
      "args": "const rd_file_view_type *rd_file_view, const char *kw"
    },
    {
      "ret": "void",
      "name": "rd_file_view_fwrite",
      "args": "const rd_file_view_type *rd_file_view, fortio_type *target, int offset"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_view_add_blockview",
      "args": "rd_file_view_type *rd_file_view, const char *header, int occurence"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_view_add_blockview2",
      "args": "rd_file_view_type *rd_file_view, const char *start_kw, const char *end_kw, int occurence"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_view_add_restart_view",
      "args": "rd_file_view_type *file_view, int seqnum_index, int report_step, time_t sim_time, double sim_days"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_view_alloc_blockview2",
      "args": "const rd_file_view_type *rd_file_view, const char *start_kw, const char *end_kw, int occurence"
    },
    {
      "ret": "bool",
      "name": "rd_file_view_drop_flag",
      "args": "rd_file_view_type *file_view, int flag"
    },
    {
      "ret": "void",
      "name": "rd_file_view_add_flag",
      "args": "rd_file_view_type *file_view, int flag"
    },
    {
      "ret": "bool",
      "name": "rd_file_view_has_sim_time",
      "args": "const rd_file_view_type *rd_file_view, time_t sim_time"
    },
    {
      "ret": "int",
      "name": "rd_file_view_find_sim_time",
      "args": "const rd_file_view_type *rd_file_view, time_t sim_time"
    },
    {
      "ret": "double",
      "name": "rd_file_view_iget_restart_sim_days",
      "args": "const rd_file_view_type *rd_file_view, int seqnum_index"
    },
    {
      "ret": "time_t",
      "name": "rd_file_view_iget_restart_sim_date",
      "args": "const rd_file_view_type *rd_file_view, int seqnum_index"
    },
    {
      "ret": "bool",
      "name": "rd_file_view_has_report_step",
      "args": "const rd_file_view_type *rd_file_view, int report_step"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_view_add_summary_view",
      "args": "rd_file_view_type *file_view, int report_step"
    },
    {
      "ret": "const char *",
      "name": "rd_file_view_get_src_file",
      "args": "const rd_file_view_type *file_view"
    },
    {
      "ret": "void",
      "name": "rd_file_view_fclose_stream",
      "args": "rd_file_view_type *file_view"
    },
    {
      "ret": "void",
      "name": "rd_file_view_write_index",
      "args": "const rd_file_view_type *file_view, FILE *ostream"
    },
    {
      "ret": "rd_file_view_type *",
      "name": "rd_file_view_fread_alloc",
      "args": "fortio_type *fortio, int *flags, inv_map_type *inv_map, FILE *istream"
    },
    {
      "ret": "rd_file_transaction_type *",
      "name": "rd_file_view_start_transaction",
      "args": "rd_file_view_type *file_view"
    },
    {
      "ret": "void",
      "name": "rd_file_view_end_transaction",
      "args": "rd_file_view_type *file_view, rd_file_transaction_type *transaction"
    }
  ],
  "resdata\\rd_grav.hpp": [
    {
      "ret": "void",
      "name": "rd_grav_free",
      "args": "rd_grav_type *rd_grav_config"
    },
    {
      "ret": "rd_grav_type *",
      "name": "rd_grav_alloc",
      "args": "const rd_grid_type *rd_grid, const rd_file_type *init_file"
    },
    {
      "ret": "rd_grav_survey_type *",
      "name": "rd_grav_add_survey_FIP",
      "args": "rd_grav_type *grav, const char *name, const rd_file_view_type *restart_file"
    },
    {
      "ret": "rd_grav_survey_type *",
      "name": "rd_grav_add_survey_PORMOD",
      "args": "rd_grav_type *grav, const char *name, const rd_file_view_type *restart_file"
    },
    {
      "ret": "rd_grav_survey_type *",
      "name": "rd_grav_add_survey_RPORV",
      "args": "rd_grav_type *grav, const char *name, const rd_file_view_type *restart_file"
    },
    {
      "ret": "rd_grav_survey_type *",
      "name": "rd_grav_add_survey_RFIP",
      "args": "rd_grav_type *grav, const char *name, const rd_file_view_type *restart_file"
    },
    {
      "ret": "double",
      "name": "rd_grav_eval",
      "args": "const rd_grav_type *grav, const char *base, const char *monitor, rd_region_type *region, double utm_x, double utm_y, double depth, int phase_mask"
    },
    {
      "ret": "void",
      "name": "rd_grav_new_std_density",
      "args": "rd_grav_type *grav, rd_phase_enum phase, double default_density"
    },
    {
      "ret": "void",
      "name": "rd_grav_add_std_density",
      "args": "rd_grav_type *grav, rd_phase_enum phase, int pvtnum, double density"
    }
  ],
  "resdata\\rd_grav_common.hpp": [
    {
      "ret": "bool *",
      "name": "rd_grav_common_alloc_aquifer_cell",
      "args": "const rd::rd_grid_cache &grid_cache, const rd_file_type *init_file"
    },
    {
      "ret": "double",
      "name": "rd_grav_common_eval_biot_savart",
      "args": "const rd::rd_grid_cache &grid_cache, rd_region_type *region, const bool *aquifer, const double *weight, double utm_x, double utm_y, double depth"
    },
    {
      "ret": "double",
      "name": "rd_grav_common_eval_geertsma",
      "args": "const rd::rd_grid_cache &grid_cache, rd_region_type *region, const bool *aquifer, const double *weight, double utm_x, double utm_y, double depth, double poisson_ratio, double seabed"
    }
  ],
  "resdata\\rd_grid.hpp": [
    {
      "ret": "#define",
      "name": "RD_GRID_COORD_SIZE",
      "args": "nx, ny) (((nx) + 1) * ((ny) + 1) * 6"
    },
    {
      "ret": "#define",
      "name": "RD_GRID_ZCORN_SIZE",
      "args": "nx, ny, nz) (((nx) * (ny) * (nz) * 8)"
    },
    {
      "ret": "bool",
      "name": "rd_grid_have_coarse_cells",
      "args": "const rd_grid_type *main_grid"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_in_coarse_group1",
      "args": "const rd_grid_type *main_grid, int global_index"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_num_coarse_groups",
      "args": "const rd_grid_type *main_grid"
    },
    {
      "ret": "rd_coarse_cell_type *",
      "name": "rd_grid_iget_coarse_group",
      "args": "const rd_grid_type *rd_grid, int coarse_nr"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_column_property",
      "args": "const rd_grid_type *rd_grid, const rd_kw_type *rd_kw, int i, int j, double_vector_type *column"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_cell_corner_xyz1",
      "args": "const rd_grid_type *grid, int global_index, int corner_nr, double *xpos, double *ypos, double *zpos"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_corner_xyz",
      "args": "const rd_grid_type *grid, int i, int j, int k, double *xpos, double *ypos, double *zpos"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_dx1A",
      "args": "const rd_grid_type *grid, int active_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_dy1A",
      "args": "const rd_grid_type *grid, int active_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_dz1A",
      "args": "const rd_grid_type *grid, int active_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_dx1",
      "args": "const rd_grid_type *grid, int global_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_dy1",
      "args": "const rd_grid_type *grid, int global_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_dz1",
      "args": "const rd_grid_type *grid, int global_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_thickness1",
      "args": "const rd_grid_type *grid, int global_index"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_distance",
      "args": "const rd_grid_type *grid, int global_index1, int global_index2, double *dx, double *dy, double *dz"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cdepth1A",
      "args": "const rd_grid_type *grid, int active_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cdepth1",
      "args": "const rd_grid_type *grid, int global_index"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_contains_xyz1",
      "args": "const rd_grid_type *rd_grid, int global_index, double x, double y, double z"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_volume1",
      "args": "const rd_grid_type *rd_grid, int global_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_cell_volume1A",
      "args": "const rd_grid_type *rd_grid, int active_index"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_contains1",
      "args": "const rd_grid_type *grid, int global_index, double x, double y, double z"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_global_index_from_xyz",
      "args": "rd_grid_type *grid, double x, double y, double z, int start_index"
    },
    {
      "ret": "bool",
      "name": "rd_grid_get_ij_from_xy",
      "args": "const rd_grid_type *grid, double x, double y, int k, int *i, int *j"
    },
    {
      "ret": "const char *",
      "name": "rd_grid_get_name",
      "args": "const rd_grid_type *"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_active_index3",
      "args": "const rd_grid_type *rd_grid, int i, int j, int k"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_active_index1",
      "args": "const rd_grid_type *rd_grid, int global_index"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_active_fracture_index1",
      "args": "const rd_grid_type *rd_grid, int global_index"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_active3",
      "args": "const rd_grid_type *, int, int, int"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_active1",
      "args": "const rd_grid_type *, int"
    },
    {
      "ret": "bool",
      "name": "rd_grid_ijk_valid",
      "args": "const rd_grid_type *, int, int, int"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_global_index3",
      "args": "const rd_grid_type *, int, int, int"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_global_index1A",
      "args": "const rd_grid_type *rd_grid, int active_index"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_global_index1F",
      "args": "const rd_grid_type *rd_grid, int active_fracture_index"
    },
    {
      "ret": "const nnc_info_type *",
      "name": "rd_grid_get_cell_nnc_info1",
      "args": "const rd_grid_type *grid, int global_index"
    },
    {
      "ret": "void",
      "name": "rd_grid_add_self_nnc",
      "args": "rd_grid_type *grid1, int g1, int g2, int nnc_index"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_alloc_GRDECL_kw",
      "args": "int nx, int ny, int nz, const rd_kw_type *zcorn_kw, const rd_kw_type *coord_kw, const rd_kw_type *actnum_kw, const rd_kw_type *mapaxes_kw"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_alloc",
      "args": "const char *"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_load_case",
      "args": "const char *case_input"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_load_case__",
      "args": "const char *case_input, bool apply_mapaxes"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_alloc_rectangular",
      "args": "int nx, int ny, int nz, double dx, double dy, double dz, const int *actnum"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_grid_alloc_volume_kw",
      "args": "const rd_grid_type *grid, bool active_size"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_grid_alloc_mapaxes_kw",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_grid_alloc_coord_kw",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "bool",
      "name": "rd_grid_exists",
      "args": "const char *case_input"
    },
    {
      "ret": "void",
      "name": "rd_grid_free",
      "args": "rd_grid_type *"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_dims",
      "args": "const rd_grid_type *, int *, int *, int *, int *"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_nz",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_nx",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_ny",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_nactive",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_nactive_fracture",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_active_index",
      "args": "const rd_grid_type *, int, int, int"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_ijk1",
      "args": "const rd_grid_type *, int global_index, int *, int *, int *"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_ijk1A",
      "args": "const rd_grid_type *, int active_index, int *, int *, int *"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_xyz3",
      "args": "const rd_grid_type *, int, int, int, double *, double *, double *"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_xyz1",
      "args": "const rd_grid_type *grid, int global_index, double *xpos, double *ypos, double *zpos"
    },
    {
      "ret": "void",
      "name": "rd_grid_get_xyz1A",
      "args": "const rd_grid_type *grid, int active_index, double *xpos, double *ypos, double *zpos"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_global_size",
      "args": "const rd_grid_type *rd_grid"
    },
    {
      "ret": "bool",
      "name": "rd_grid_compare",
      "args": "const rd_grid_type *g1, const rd_grid_type *g2, bool include_lgr, bool include_nnc, bool verbose"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_active_size",
      "args": "const rd_grid_type *rd_grid"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_top1A",
      "args": "const rd_grid_type *grid, int active_index"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_top2",
      "args": "const rd_grid_type *grid, int i, int j"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_bottom2",
      "args": "const rd_grid_type *grid, int i, int j"
    },
    {
      "ret": "int",
      "name": "rd_grid_locate_depth",
      "args": "const rd_grid_type *grid, double depth, int i, int j"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_invalid1",
      "args": "const rd_grid_type *rd_grid, int global_index"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_valid1",
      "args": "const rd_grid_type *rd_grid, int global_index"
    },
    {
      "ret": "const rd_grid_type *",
      "name": "rd_grid_get_cell_lgr1",
      "args": "const rd_grid_type *grid, int global_index"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_num_lgr",
      "args": "const rd_grid_type *main_grid"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_lgr_nr",
      "args": "const rd_grid_type *rd_grid"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_lgr_nr_from_name",
      "args": "const rd_grid_type *grid, const char *name"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_iget_lgr",
      "args": "const rd_grid_type *main_grid, int lgr_index"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_get_lgr_from_lgr_nr",
      "args": "const rd_grid_type *main_grid, int lgr_nr"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_get_lgr",
      "args": "const rd_grid_type *main_grid, const char *__lgr_name"
    },
    {
      "ret": "bool",
      "name": "rd_grid_has_lgr",
      "args": "const rd_grid_type *main_grid, const char *__lgr_name"
    },
    {
      "ret": "bool",
      "name": "rd_grid_has_lgr_nr",
      "args": "const rd_grid_type *main_grid, int lgr_nr"
    },
    {
      "ret": "const char *",
      "name": "rd_grid_iget_lgr_name",
      "args": "const rd_grid_type *rd_grid, int lgr_index"
    },
    {
      "ret": "const char *",
      "name": "rd_grid_get_lgr_name",
      "args": "const rd_grid_type *rd_grid, int lgr_nr"
    },
    {
      "ret": "double",
      "name": "rd_grid_get_property",
      "args": "const rd_grid_type *rd_grid, const rd_kw_type *rd_kw, int i, int j, int k"
    },
    {
      "ret": "void",
      "name": "rd_grid_grdecl_fprintf_kw",
      "args": "const rd_grid_type *rd_grid, const rd_kw_type *rd_kw, const char *special_header, FILE *stream, double double_default"
    },
    {
      "ret": "bool",
      "name": "rd_grid_test_lgr_consistency",
      "args": "const rd_grid_type *rd_grid"
    },
    {
      "ret": "void",
      "name": "rd_grid_fwrite_EGRID",
      "args": "rd_grid_type *grid, const char *filename, bool metric_output"
    },
    {
      "ret": "void",
      "name": "rd_grid_fwrite_EGRID2",
      "args": "rd_grid_type *grid, const char *filename, ert_rd_unit_enum output_unit"
    },
    {
      "ret": "void",
      "name": "rd_grid_fwrite_GRID2",
      "args": "const rd_grid_type *grid, const char *filename, ert_rd_unit_enum output_unit"
    },
    {
      "ret": "void",
      "name": "rd_grid_fprintf_grdecl2",
      "args": "rd_grid_type *grid, FILE *stream, ert_rd_unit_enum output_unit"
    },
    {
      "ret": "int",
      "name": "rd_grid_zcorn_index__",
      "args": "int nx, int ny, int i, int j, int k, int c"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_grid_alloc_zcorn_kw",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_grid_alloc_actnum_kw",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "rd_grid_type *",
      "name": "rd_grid_alloc_copy",
      "args": "const rd_grid_type *src_grid"
    },
    {
      "ret": "bool",
      "name": "rd_grid_dual_grid",
      "args": "const rd_grid_type *rd_grid"
    },
    {
      "ret": "bool",
      "name": "rd_grid_cell_regular1",
      "args": "const rd_grid_type *rd_grid, int global_index"
    },
    {
      "ret": "void",
      "name": "rd_grid_init_zcorn_data",
      "args": "const rd_grid_type *grid, float *zcorn"
    },
    {
      "ret": "void",
      "name": "rd_grid_init_zcorn_data_double",
      "args": "const rd_grid_type *grid, double *zcorn"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_zcorn_size",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "void",
      "name": "rd_grid_init_coord_data",
      "args": "const rd_grid_type *grid, float *coord"
    },
    {
      "ret": "void",
      "name": "rd_grid_init_coord_data_double",
      "args": "const rd_grid_type *grid, double *coord"
    },
    {
      "ret": "int",
      "name": "rd_grid_get_coord_size",
      "args": "const rd_grid_type *rd_grid"
    },
    {
      "ret": "void",
      "name": "rd_grid_init_actnum_data",
      "args": "const rd_grid_type *grid, int *actnum"
    },
    {
      "ret": "bool",
      "name": "rd_grid_use_mapaxes",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "void",
      "name": "rd_grid_init_mapaxes_data_double",
      "args": "const rd_grid_type *grid, double *mapaxes"
    },
    {
      "ret": "void",
      "name": "rd_grid_reset_actnum",
      "args": "rd_grid_type *grid, const int *actnum"
    },
    {
      "ret": "void",
      "name": "rd_grid_compressed_kw_copy",
      "args": "const rd_grid_type *grid, rd_kw_type *target_kw, const rd_kw_type *src_kw"
    },
    {
      "ret": "void",
      "name": "rd_grid_global_kw_copy",
      "args": "const rd_grid_type *grid, rd_kw_type *target_kw, const rd_kw_type *src_kw"
    },
    {
      "ret": "void",
      "name": "rd_grid_export_cell_corners1",
      "args": "const rd_grid_type *grid, int global_index, double *x, double *y, double *z"
    },
    {
      "ret": "ert_rd_unit_enum",
      "name": "rd_grid_get_unit_system",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "void",
      "name": "rd_grid_export_index",
      "args": "const rd_grid_type *grid, int *global_index, int *index_data, bool active_only"
    },
    {
      "ret": "void",
      "name": "rd_grid_export_data_as_int",
      "args": "int index_size, const int *global_index, const rd_kw_type *kw, int *output"
    },
    {
      "ret": "void",
      "name": "rd_grid_export_data_as_double",
      "args": "int index_size, const int *data_index, const rd_kw_type *kw, double *output"
    },
    {
      "ret": "void",
      "name": "rd_grid_export_volume",
      "args": "const rd_grid_type *grid, int index_size, const int *global_index, double *output"
    },
    {
      "ret": "void",
      "name": "rd_grid_export_position",
      "args": "const rd_grid_type *grid, int index_size, const int *global_index, double *output"
    },
    {
      "ret": "void",
      "name": "export_corners",
      "args": "const rd_grid_type *grid, int index_size, const int *global_index, double *output"
    },
    {
      "ret": "float",
      "name": "rd_grid_output_scaling",
      "args": "const rd_grid_type *grid, ert_rd_unit_enum output_unit"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "rd_grid"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "rd_grid"
    }
  ],
  "resdata\\rd_kw.hpp": [
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "rd_kw"
    },
    {
      "ret": "int",
      "name": "rd_kw_first_different",
      "args": "const rd_kw_type *kw1, const rd_kw_type *kw2, int offset, double abs_epsilon, double rel_epsilon"
    },
    {
      "ret": "size_t",
      "name": "rd_kw_fortio_size",
      "args": "const rd_kw_type *rd_kw"
    },
    {
      "ret": "void *",
      "name": "rd_kw_get_ptr",
      "args": "const rd_kw_type *rd_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_set_data_ptr",
      "args": "rd_kw_type *rd_kw, void *data"
    },
    {
      "ret": "void",
      "name": "rd_kw_fwrite_data",
      "args": "const rd_kw_type *_rd_kw, fortio_type *fortio"
    },
    {
      "ret": "bool",
      "name": "rd_kw_fread_realloc_data",
      "args": "rd_kw_type *rd_kw, fortio_type *fortio"
    },
    {
      "ret": "rd_data_type",
      "name": "rd_kw_get_data_type",
      "args": "const rd_kw_type *"
    },
    {
      "ret": "const char *",
      "name": "rd_kw_get_header",
      "args": "const rd_kw_type *rd_kw"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_empty",
      "args": "void"
    },
    {
      "ret": "rd_read_status_enum",
      "name": "rd_kw_fread_header",
      "args": "rd_kw_type *, fortio_type *"
    },
    {
      "ret": "void",
      "name": "rd_kw_set_header_name",
      "args": "rd_kw_type *, const char *"
    },
    {
      "ret": "bool",
      "name": "rd_kw_fseek_kw",
      "args": "const char *, bool, bool, fortio_type *"
    },
    {
      "ret": "void",
      "name": "rd_kw_fskip",
      "args": "fortio_type *"
    },
    {
      "ret": "bool",
      "name": "rd_kw_fread_realloc",
      "args": "rd_kw_type *, fortio_type *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_fread_alloc",
      "args": "fortio_type *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_actnum",
      "args": "const rd_kw_type *porv_kw, float porv_limit"
    },
    {
      "ret": "void",
      "name": "rd_kw_fread_indexed_data",
      "args": "fortio_type *fortio, offset_type data_offset, rd_data_type, int element_count, const int_vector_type *index_map, char *buffer"
    },
    {
      "ret": "void",
      "name": "rd_kw_free",
      "args": "rd_kw_type *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_copy",
      "args": "const rd_kw_type *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_sub_copy",
      "args": "const rd_kw_type *src, const char *new_kw, int offset, int count"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_slice_copy",
      "args": "const rd_kw_type *src, int index1, int index2, int stride"
    },
    {
      "ret": "void",
      "name": "rd_kw_resize",
      "args": "rd_kw_type *rd_kw, int new_size"
    },
    {
      "ret": "void",
      "name": "rd_kw_memcpy",
      "args": "rd_kw_type *, const rd_kw_type *"
    },
    {
      "ret": "void",
      "name": "rd_kw_get_memcpy_data",
      "args": "const rd_kw_type *, void *"
    },
    {
      "ret": "void",
      "name": "rd_kw_set_memcpy_data",
      "args": "rd_kw_type *, const void *"
    },
    {
      "ret": "bool",
      "name": "rd_kw_fwrite",
      "args": "const rd_kw_type *, fortio_type *"
    },
    {
      "ret": "void",
      "name": "rd_kw_iget",
      "args": "const rd_kw_type *, int, void *"
    },
    {
      "ret": "void",
      "name": "rd_kw_iset",
      "args": "rd_kw_type *rd_kw, int i, const void *iptr"
    },
    {
      "ret": "void",
      "name": "rd_kw_iset_char_ptr",
      "args": "rd_kw_type *rd_kw, int index, const char *s"
    },
    {
      "ret": "void",
      "name": "rd_kw_iset_string8",
      "args": "rd_kw_type *rd_kw, int index, const char *s8"
    },
    {
      "ret": "void",
      "name": "rd_kw_iset_string_ptr",
      "args": "rd_kw_type *, int, const char *"
    },
    {
      "ret": "const char *",
      "name": "rd_kw_iget_string_ptr",
      "args": "const rd_kw_type *, int"
    },
    {
      "ret": "const char *",
      "name": "rd_kw_iget_char_ptr",
      "args": "const rd_kw_type *rd_kw, int i"
    },
    {
      "ret": "void *",
      "name": "rd_kw_iget_ptr",
      "args": "const rd_kw_type *, int"
    },
    {
      "ret": "int",
      "name": "rd_kw_get_size",
      "args": "const rd_kw_type *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc",
      "args": "const char *header, int size, rd_data_type"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_new",
      "args": "const char *, int, rd_data_type, const void *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_new_shared",
      "args": "const char *, int, rd_data_type, void *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_global_copy",
      "args": "const rd_kw_type *src, const rd_kw_type *actnum"
    },
    {
      "ret": "void",
      "name": "rd_kw_summarize",
      "args": "const rd_kw_type *rd_kw"
    },
    {
      "ret": "double",
      "name": "rd_kw_iget_as_double",
      "args": "const rd_kw_type *rd_kw, int i"
    },
    {
      "ret": "bool",
      "name": "rd_kw_equal",
      "args": "const rd_kw_type *rd_kw1, const rd_kw_type *rd_kw2"
    },
    {
      "ret": "bool",
      "name": "rd_kw_size_and_type_equal",
      "args": "const rd_kw_type *rd_kw1, const rd_kw_type *rd_kw2"
    },
    {
      "ret": "bool",
      "name": "rd_kw_icmp_string",
      "args": "const rd_kw_type *rd_kw, int index, const char *other_string"
    },
    {
      "ret": "bool",
      "name": "rd_kw_numeric_equal",
      "args": "const rd_kw_type *rd_kw1, const rd_kw_type *rd_kw2, double abs_diff, double rel_diff"
    },
    {
      "ret": "bool",
      "name": "rd_kw_data_equal",
      "args": "const rd_kw_type *rd_kw, const void *data"
    },
    {
      "ret": "bool",
      "name": "rd_kw_content_equal",
      "args": "const rd_kw_type *rd_kw1, const rd_kw_type *rd_kw2"
    },
    {
      "ret": "bool",
      "name": "rd_kw_fskip_data__",
      "args": "rd_data_type, int, fortio_type *"
    },
    {
      "ret": "bool",
      "name": "rd_kw_fskip_data",
      "args": "rd_kw_type *rd_kw, fortio_type *fortio"
    },
    {
      "ret": "void",
      "name": "rd_kw_fskip_header",
      "args": "fortio_type *fortio"
    },
    {
      "ret": "bool",
      "name": "rd_kw_size_and_numeric_type_equal",
      "args": "const rd_kw_type *kw1, const rd_kw_type *kw2"
    },
    {
      "ret": "bool",
      "name": "rd_kw_inplace_safe_div",
      "args": "rd_kw_type *target_kw, const rd_kw_type *divisor"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_sqrt",
      "args": "rd_kw_type *kw"
    },
    {
      "ret": "int",
      "name": "rd_kw_element_sum_int",
      "args": "const rd_kw_type *rd_kw"
    },
    {
      "ret": "double",
      "name": "rd_kw_element_sum_float",
      "args": "const rd_kw_type *rd_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_element_sum",
      "args": "const rd_kw_type *, void *"
    },
    {
      "ret": "void",
      "name": "rd_kw_element_sum_indexed",
      "args": "const rd_kw_type *rd_kw, const int_vector_type *index_list, void *_sum"
    },
    {
      "ret": "void",
      "name": "rd_kw_max_min",
      "args": "const rd_kw_type *, void *, void *"
    },
    {
      "ret": "void *",
      "name": "rd_kw_get_void_ptr",
      "args": "const rd_kw_type *rd_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_fprintf_data",
      "args": "const rd_kw_type *rd_kw, const char *fmt, FILE *stream"
    },
    {
      "ret": "void",
      "name": "rd_kw_memcpy_data",
      "args": "rd_kw_type *target, const rd_kw_type *src"
    },
    {
      "ret": "void",
      "name": "rd_kw_scalar_set_float_or_double",
      "args": "rd_kw_type *rd_kw, double value"
    },
    {
      "ret": "void rd_kw_scalar_set_##",
      "name": "ctype",
      "args": "rd_kw_type *rd_kw, ctype value"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_alloc_scatter_copy",
      "args": "const rd_kw_type *src_kw, int target_size, const int *mapping, void *def_value"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_add_squared",
      "args": "rd_kw_type *target_kw, const rd_kw_type *add_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_add",
      "args": "rd_kw_type *target_kw, const rd_kw_type *add_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_sub",
      "args": "rd_kw_type *target_kw, const rd_kw_type *sub_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_div",
      "args": "rd_kw_type *target_kw, const rd_kw_type *div_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_mul",
      "args": "rd_kw_type *target_kw, const rd_kw_type *mul_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_abs",
      "args": "rd_kw_type *kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_add_indexed",
      "args": "rd_kw_type *target_kw, const int_vector_type *index_set, const rd_kw_type *add_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_sub_indexed",
      "args": "rd_kw_type *target_kw, const int_vector_type *index_set, const rd_kw_type *sub_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_mul_indexed",
      "args": "rd_kw_type *target_kw, const int_vector_type *index_set, const rd_kw_type *mul_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_inplace_div_indexed",
      "args": "rd_kw_type *target_kw, const int_vector_type *index_set, const rd_kw_type *div_kw"
    },
    {
      "ret": "void",
      "name": "rd_kw_copy_indexed",
      "args": "rd_kw_type *target_kw, const int_vector_type *index_set, const rd_kw_type *src_kw"
    },
    {
      "ret": "bool",
      "name": "rd_kw_assert_binary_numeric",
      "args": "const rd_kw_type *kw1, const rd_kw_type *kw2"
    },
    {
      "ret": "bool",
      "name": "rd_kw_assert_numeric",
      "args": "const rd_kw_type *kw"
    },
    {
      "ret": "bool",
      "name": "rd_kw_assert_binary",
      "args": "const rd_kw_type *kw1, const rd_kw_type *kw2"
    },
    {
      "ret": "bool rd_kw_assert_binary_##",
      "name": "ctype",
      "args": "const rd_kw_type *kw1,                    \\ const rd_kw_type *kw2) RD_KW_ASSERT_TYPED_BINARY_OP_HEADER(int"
    },
    {
      "ret": "",
      "name": "RD_KW_ASSERT_TYPED_BINARY_OP_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_ASSERT_TYPED_BINARY_OP_HEADER",
      "args": "double"
    },
    {
      "ret": "",
      "name": "RD_KW_SCALE_TYPED_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_SCALE_TYPED_HEADER",
      "args": "double"
    },
    {
      "ret": "void",
      "name": "rd_kw_scale_float_or_double",
      "args": "rd_kw_type *rd_kw, double scale_factor"
    },
    {
      "ret": "",
      "name": "RD_KW_SHIFT_TYPED_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_SHIFT_TYPED_HEADER",
      "args": "double"
    },
    {
      "ret": "void",
      "name": "rd_kw_shift_float_or_double",
      "args": "rd_kw_type *rd_kw, double shift_value"
    },
    {
      "ret": "type rd_kw_iget_##",
      "name": "type",
      "args": "const rd_kw_type *, int) RD_KW_IGET_TYPED_HEADER(double"
    },
    {
      "ret": "",
      "name": "RD_KW_IGET_TYPED_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_IGET_TYPED_HEADER",
      "args": "int"
    },
    {
      "ret": "bool",
      "name": "rd_kw_iget_bool",
      "args": "const rd_kw_type *rd_kw, int i"
    },
    {
      "ret": "void rd_kw_iset_##",
      "name": "type",
      "args": "rd_kw_type *, int, type) RD_KW_ISET_TYPED_HEADER(double"
    },
    {
      "ret": "",
      "name": "RD_KW_ISET_TYPED_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_ISET_TYPED_HEADER",
      "args": "int"
    },
    {
      "ret": "void",
      "name": "rd_kw_iset_bool",
      "args": "rd_kw_type *rd_kw, int i, bool bool_value"
    },
    {
      "ret": "type *rd_kw_get_##type##",
      "name": "_ptr",
      "args": "const rd_kw_type *) RD_KW_GET_TYPED_PTR_HEADER(double"
    },
    {
      "ret": "",
      "name": "RD_KW_GET_TYPED_PTR_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_GET_TYPED_PTR_HEADER",
      "args": "int"
    },
    {
      "ret": "",
      "name": "RD_KW_GET_TYPED_PTR_HEADER",
      "args": "bool"
    },
    {
      "ret": "void rd_kw_set_indexed_##",
      "name": "ctype",
      "args": "\\ rd_kw_type *rd_kw, const int_vector_type *index_list, ctype value) RD_KW_SET_INDEXED_HEADER(double"
    },
    {
      "ret": "",
      "name": "RD_KW_SET_INDEXED_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_SET_INDEXED_HEADER",
      "args": "int"
    },
    {
      "ret": "",
      "name": "RD_KW_SHIFT_INDEXED_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_SHIFT_INDEXED_HEADER",
      "args": "double"
    },
    {
      "ret": "",
      "name": "RD_KW_SCALE_INDEXED_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_SCALE_INDEXED_HEADER",
      "args": "double"
    },
    {
      "ret": "void rd_kw_max_min_##",
      "name": "ctype",
      "args": "const rd_kw_type *rd_kw, ctype *_max,           \\ ctype *_min) RD_KW_MAX_MIN_HEADER(int"
    },
    {
      "ret": "",
      "name": "RD_KW_MAX_MIN_HEADER",
      "args": "float"
    },
    {
      "ret": "",
      "name": "RD_KW_MAX_MIN_HEADER",
      "args": "double"
    },
    {
      "ret": "void",
      "name": "rd_kw_fix_uninitialized",
      "args": "rd_kw_type *rd_kw, int nx, int ny, int nz, const int *actnum"
    },
    {
      "ret": "rd_type_enum",
      "name": "rd_kw_get_type",
      "args": "const rd_kw_type *"
    }
  ],
  "resdata\\rd_kw_grdecl.hpp": [
    {
      "ret": "bool",
      "name": "rd_kw_grdecl_fseek_kw",
      "args": "const char *, bool, FILE *"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_fscanf_alloc_grdecl_dynamic__",
      "args": "FILE *stream, const char *kw, bool strict, rd_data_type"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_fscanf_alloc_grdecl_dynamic",
      "args": "FILE *stream, const char *kw, rd_data_type"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_fscanf_alloc_grdecl",
      "args": "FILE *stream, const char *kw, int size, rd_data_type data_type"
    },
    {
      "ret": "rd_kw_type *",
      "name": "rd_kw_fscanf_alloc_current_grdecl",
      "args": "FILE *stream, rd_data_type data_type"
    },
    {
      "ret": "void",
      "name": "rd_kw_fprintf_grdecl",
      "args": "const rd_kw_type *rd_kw, FILE *stream"
    },
    {
      "ret": "void",
      "name": "rd_kw_fprintf_grdecl__",
      "args": "const rd_kw_type *rd_kw, const char *special_header, FILE *stream"
    }
  ],
  "resdata\\rd_region.hpp": [
    {
      "ret": "void",
      "name": "rd_region_reset",
      "args": "rd_region_type *rd_region"
    },
    {
      "ret": "rd_region_type *",
      "name": "rd_region_alloc_copy",
      "args": "const rd_region_type *rd_region"
    },
    {
      "ret": "rd_region_type *",
      "name": "rd_region_alloc",
      "args": "const rd_grid_type *rd_grid, bool preselect"
    },
    {
      "ret": "void",
      "name": "rd_region_free",
      "args": "rd_region_type *region"
    },
    {
      "ret": "const int_vector_type *",
      "name": "rd_region_get_active_list",
      "args": "rd_region_type *region"
    },
    {
      "ret": "const int_vector_type *",
      "name": "rd_region_get_global_list",
      "args": "rd_region_type *region"
    },
    {
      "ret": "const int_vector_type *",
      "name": "rd_region_get_global_active_list",
      "args": "rd_region_type *region"
    },
    {
      "ret": "bool",
      "name": "rd_region_contains_ijk",
      "args": "const rd_region_type *rd_region, int i, int j, int k"
    },
    {
      "ret": "bool",
      "name": "rd_region_contains_global",
      "args": "const rd_region_type *rd_region, int global_index"
    },
    {
      "ret": "bool",
      "name": "rd_region_contains_active",
      "args": "const rd_region_type *rd_region, int active_index"
    },
    {
      "ret": "void",
      "name": "rd_region_select_true",
      "args": "rd_region_type *region, const rd_kw_type *rd_kw"
    },
    {
      "ret": "void",
      "name": "rd_region_invert_selection",
      "args": "rd_region_type *region"
    },
    {
      "ret": "void",
      "name": "rd_region_select_all",
      "args": "rd_region_type *region"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_all",
      "args": "rd_region_type *region"
    },
    {
      "ret": "void",
      "name": "rd_region_select_false",
      "args": "rd_region_type *region, const rd_kw_type *rd_kw"
    },
    {
      "ret": "void",
      "name": "rd_region_select_in_interval",
      "args": "rd_region_type *region, const rd_kw_type *rd_kw, float min_value, float max_value"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_in_interval",
      "args": "rd_region_type *region, const rd_kw_type *rd_kw, float min_value, float max_value"
    },
    {
      "ret": "void",
      "name": "rd_region_select_equal",
      "args": "rd_region_type *region, const rd_kw_type *rd_kw, int value"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_equal",
      "args": "rd_region_type *region, const rd_kw_type *rd_kw, int value"
    },
    {
      "ret": "void",
      "name": "rd_region_select_inactive_cells",
      "args": "rd_region_type *region"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_inactive_cells",
      "args": "rd_region_type *region"
    },
    {
      "ret": "void",
      "name": "rd_region_select_active_cells",
      "args": "rd_region_type *region"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_active_cells",
      "args": "rd_region_type *region"
    },
    {
      "ret": "void",
      "name": "rd_region_select_from_ijkbox",
      "args": "rd_region_type *region, int i1, int i2, int j1, int j2, int k1, int k2"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_from_ijkbox",
      "args": "rd_region_type *region, int i1, int i2, int j1, int j2, int k1, int k2"
    },
    {
      "ret": "void",
      "name": "rd_region_select_i1i2",
      "args": "rd_region_type *region, int i1, int i2"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_i1i2",
      "args": "rd_region_type *region, int i1, int i2"
    },
    {
      "ret": "void",
      "name": "rd_region_select_j1j2",
      "args": "rd_region_type *region, int j1, int j2"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_j1j2",
      "args": "rd_region_type *region, int j1, int i2"
    },
    {
      "ret": "void",
      "name": "rd_region_select_k1k2",
      "args": "rd_region_type *region, int k1, int k2"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_k1k2",
      "args": "rd_region_type *region, int k1, int i2"
    },
    {
      "ret": "void",
      "name": "rd_region_select_shallow_cells",
      "args": "rd_region_type *region, double depth_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_shallow_cells",
      "args": "rd_region_type *region, double depth_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_select_deep_cells",
      "args": "rd_region_type *region, double depth_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_deep_cells",
      "args": "rd_region_type *region, double depth_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_select_thin_cells",
      "args": "rd_region_type *rd_region, double dz_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_thin_cells",
      "args": "rd_region_type *rd_region, double dz_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_select_thick_cells",
      "args": "rd_region_type *rd_region, double dz_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_thick_cells",
      "args": "rd_region_type *rd_region, double dz_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_select_small_cells",
      "args": "rd_region_type *rd_region, double volum_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_small_cells",
      "args": "rd_region_type *rd_region, double volum_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_select_large_cells",
      "args": "rd_region_type *rd_region, double volum_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_large_cells",
      "args": "rd_region_type *rd_region, double volum_limit"
    },
    {
      "ret": "void",
      "name": "rd_region_intersection",
      "args": "rd_region_type *region, const rd_region_type *new_region"
    },
    {
      "ret": "void",
      "name": "rd_region_union",
      "args": "rd_region_type *region, const rd_region_type *new_region"
    },
    {
      "ret": "void",
      "name": "rd_region_subtract",
      "args": "rd_region_type *region, const rd_region_type *new_region"
    },
    {
      "ret": "void",
      "name": "rd_region_xor",
      "args": "rd_region_type *region, const rd_region_type *new_region"
    },
    {
      "ret": "void",
      "name": "rd_region_select_smaller",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, float limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_smaller",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, float limit"
    },
    {
      "ret": "void",
      "name": "rd_region_select_larger",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, float limit"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_larger",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, float limit"
    },
    {
      "ret": "void",
      "name": "rd_region_cmp_select_less",
      "args": "rd_region_type *rd_region, const rd_kw_type *kw1, const rd_kw_type *kw2"
    },
    {
      "ret": "void",
      "name": "rd_region_cmp_deselect_less",
      "args": "rd_region_type *rd_region, const rd_kw_type *kw1, const rd_kw_type *kw2"
    },
    {
      "ret": "void",
      "name": "rd_region_cmp_select_more",
      "args": "rd_region_type *rd_region, const rd_kw_type *kw1, const rd_kw_type *kw2"
    },
    {
      "ret": "void",
      "name": "rd_region_cmp_deselect_more",
      "args": "rd_region_type *rd_region, const rd_kw_type *kw1, const rd_kw_type *kw2"
    },
    {
      "ret": "void",
      "name": "rd_region_select_above_plane",
      "args": "rd_region_type *region, const double n[3], const double p[3]"
    },
    {
      "ret": "void",
      "name": "rd_region_select_below_plane",
      "args": "rd_region_type *region, const double n[3], const double p[3]"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_above_plane",
      "args": "rd_region_type *region, const double n[3], const double p[3]"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_below_plane",
      "args": "rd_region_type *region, const double n[3], const double p[3]"
    },
    {
      "ret": "void",
      "name": "rd_region_select_inside_polygon",
      "args": "rd_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_inside_polygon",
      "args": "rd_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "rd_region_select_outside_polygon",
      "args": "rd_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "rd_region_deselect_outside_polygon",
      "args": "rd_region_type *region, const geo_polygon_type *polygon"
    },
    {
      "ret": "void",
      "name": "rd_region_select_from_layer",
      "args": "rd_region_type *region, const layer_type *layer, int k, int layer_value"
    },
    {
      "ret": "void",
      "name": "rd_region_set_kw_int",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, int value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_set_kw_float",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, float value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_set_kw_double",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, double value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_kw_copy",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, const rd_kw_type *src_kw, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_kw_iadd",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, const rd_kw_type *delta_kw, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_kw_idiv",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, const rd_kw_type *div_kw, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_kw_imul",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, const rd_kw_type *mul_kw, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_kw_isub",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, const rd_kw_type *delta_kw, bool force_active"
    },
    {
      "ret": "bool",
      "name": "rd_region_equal",
      "args": "const rd_region_type *region1, const rd_region_type *region2"
    },
    {
      "ret": "void",
      "name": "rd_region_scale_kw_float",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, float value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_scale_kw_double",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, double value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_scale_kw_int",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, int value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_shift_kw_int",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, int value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_shift_kw_double",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, double value, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_shift_kw_float",
      "args": "rd_region_type *rd_region, rd_kw_type *rd_kw, float value, bool force_active"
    },
    {
      "ret": "const int_vector_type *",
      "name": "rd_region_get_kw_index_list",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, bool force_active"
    },
    {
      "ret": "void",
      "name": "rd_region_set_name",
      "args": "rd_region_type *region, const char *name"
    },
    {
      "ret": "const char *",
      "name": "rd_region_get_name",
      "args": "const rd_region_type *region"
    },
    {
      "ret": "double",
      "name": "rd_region_sum_kw_double",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, bool force_active"
    },
    {
      "ret": "int",
      "name": "rd_region_sum_kw_int",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, bool force_active"
    },
    {
      "ret": "float",
      "name": "rd_region_sum_kw_float",
      "args": "rd_region_type *rd_region, const rd_kw_type *rd_kw, bool force_active"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "rd_region"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "rd_region"
    }
  ],
  "resdata\\rd_rft_cell.hpp": [
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "rd_rft_cell"
    },
    {
      "ret": "rd_rft_cell_type *",
      "name": "rd_rft_cell_alloc_PLT",
      "args": "int i, int j, int k, double depth, double pressure, double orat, double grat, double wrat, double connection_start, double connection_end, double flowrate, double oil_flowrate, double gas_flowrate, double water_flowrate"
    },
    {
      "ret": "rd_rft_cell_type *",
      "name": "rd_rft_cell_alloc_RFT",
      "args": "int i, int j, int k, double depth, double pressure, double swat, double sgas"
    },
    {
      "ret": "void",
      "name": "rd_rft_cell_free",
      "args": "rd_rft_cell_type *cell"
    },
    {
      "ret": "bool",
      "name": "rd_rft_cell_ijk_equal",
      "args": "const rd_rft_cell_type *cell, int i, int j, int k"
    },
    {
      "ret": "void",
      "name": "rd_rft_cell_get_ijk",
      "args": "const rd_rft_cell_type *cell, int *i, int *j, int *k"
    },
    {
      "ret": "int",
      "name": "rd_rft_cell_get_i",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "int",
      "name": "rd_rft_cell_get_j",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "int",
      "name": "rd_rft_cell_get_k",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_depth",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_pressure",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_swat",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_sgas",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_soil",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_wrat",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_grat",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_orat",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_connection_start",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_connection_end",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_flowrate",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_oil_flowrate",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_gas_flowrate",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "double",
      "name": "rd_rft_cell_get_water_flowrate",
      "args": "const rd_rft_cell_type *cell"
    },
    {
      "ret": "bool",
      "name": "rd_rft_cell_lt",
      "args": "const rd_rft_cell_type *cell1, const rd_rft_cell_type *cell2"
    }
  ],
  "resdata\\rd_rft_file.hpp": [
    {
      "ret": "rd_rft_file_type *",
      "name": "rd_rft_file_alloc_case",
      "args": "const char *case_input"
    },
    {
      "ret": "bool",
      "name": "rd_rft_file_case_has_rft",
      "args": "const char *case_input"
    },
    {
      "ret": "rd_rft_file_type *",
      "name": "rd_rft_file_alloc",
      "args": "const char *"
    },
    {
      "ret": "void",
      "name": "rd_rft_file_free",
      "args": "rd_rft_file_type *"
    },
    {
      "ret": "int",
      "name": "rd_rft_file_get_size__",
      "args": "const rd_rft_file_type *rft_file, const char *well_pattern, time_t recording_time"
    },
    {
      "ret": "int",
      "name": "rd_rft_file_get_size",
      "args": "const rd_rft_file_type *rft_file"
    },
    {
      "ret": "rd_rft_node_type *",
      "name": "rd_rft_file_get_well_time_rft",
      "args": "const rd_rft_file_type *rft_file, const char *well, time_t recording_time"
    },
    {
      "ret": "rd_rft_node_type *",
      "name": "rd_rft_file_iget_node",
      "args": "const rd_rft_file_type *rft_file, int index"
    },
    {
      "ret": "int",
      "name": "rd_rft_file_get_num_wells",
      "args": "const rd_rft_file_type *rft_file"
    }
  ],
  "resdata\\rd_rft_node.hpp": [
    {
      "ret": "const rd_rft_cell_type *",
      "name": "rd_rft_node_iget_cell_sorted",
      "args": "rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "const rd_rft_cell_type *",
      "name": "rd_rft_node_iget_cell",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "const rd_rft_cell_type *",
      "name": "rd_rft_node_lookup_ijk",
      "args": "const rd_rft_node_type *rft_node, int i, int j, int k"
    },
    {
      "ret": "rd_rft_node_type *",
      "name": "rd_rft_node_alloc",
      "args": "const rd_file_view_type *rft_view"
    },
    {
      "ret": "void",
      "name": "rd_rft_node_free",
      "args": "rd_rft_node_type *"
    },
    {
      "ret": "time_t",
      "name": "rd_rft_node_get_date",
      "args": "const rd_rft_node_type *"
    },
    {
      "ret": "int",
      "name": "rd_rft_node_get_size",
      "args": "const rd_rft_node_type *"
    },
    {
      "ret": "const char *",
      "name": "rd_rft_node_get_well_name",
      "args": "const rd_rft_node_type *rft_node"
    },
    {
      "ret": "void",
      "name": "rd_rft_node_iget_ijk",
      "args": "const rd_rft_node_type *rft_node, int index, int *i, int *j, int *k"
    },
    {
      "ret": "bool",
      "name": "rd_rft_node_is_RFT",
      "args": "const rd_rft_node_type *rft_node"
    },
    {
      "ret": "bool",
      "name": "rd_rft_node_is_PLT",
      "args": "const rd_rft_node_type *rft_node"
    },
    {
      "ret": "bool",
      "name": "rd_rft_node_is_SEGMENT",
      "args": "const rd_rft_node_type *rft_node"
    },
    {
      "ret": "bool",
      "name": "rd_rft_node_is_MSW",
      "args": "const rd_rft_node_type *rft_node"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_pressure",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_depth",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_wrat",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_grat",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_orat",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_swat",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_sgas",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_iget_soil",
      "args": "const rd_rft_node_type *rft_node, int index"
    },
    {
      "ret": "double",
      "name": "rd_rft_node_get_days",
      "args": "const rd_rft_node_type *rft_node"
    },
    {
      "ret": "rd_rft_node_type *",
      "name": "rd_rft_node_alloc_new",
      "args": "const char *well_name, const char *data_type_string, const time_t recording_date, const double days"
    },
    {
      "ret": "rd_rft_enum",
      "name": "rd_rft_node_get_type",
      "args": "const rd_rft_node_type *rft_node"
    }
  ],
  "resdata\\rd_rsthead.hpp": [
    {
      "ret": "void",
      "name": "rd_rsthead_free",
      "args": "rd_rsthead_type *rsthead"
    },
    {
      "ret": "rd_rsthead_type *",
      "name": "rd_rsthead_alloc_from_kw",
      "args": "int report_step, const rd_kw_type *intehead_kw, const rd_kw_type *doubhead_kw, const rd_kw_type *logihead_kw"
    },
    {
      "ret": "rd_rsthead_type *",
      "name": "rd_rsthead_alloc",
      "args": "const rd_file_view_type *rst_file, int report_step"
    },
    {
      "ret": "time_t",
      "name": "rd_rsthead_date",
      "args": "const rd_kw_type *intehead_kw"
    },
    {
      "ret": "bool",
      "name": "rd_rsthead_equal",
      "args": "const rd_rsthead_type *header1, const rd_rsthead_type *header2"
    },
    {
      "ret": "double",
      "name": "rd_rsthead_get_sim_days",
      "args": "const rd_rsthead_type *header"
    },
    {
      "ret": "int",
      "name": "rd_rsthead_get_report_step",
      "args": "const rd_rsthead_type *header"
    },
    {
      "ret": "time_t",
      "name": "rd_rsthead_get_sim_time",
      "args": "const rd_rsthead_type *header"
    },
    {
      "ret": "int",
      "name": "rd_rsthead_get_nxconz",
      "args": "const rd_rsthead_type *rsthead"
    },
    {
      "ret": "int",
      "name": "rd_rsthead_get_ncwmax",
      "args": "const rd_rsthead_type *rsthead"
    }
  ],
  "resdata\\rd_smspec.hpp": [
    {
      "ret": "int *",
      "name": "rd_smspec_alloc_mapping",
      "args": "const rd_smspec_type *self, const rd_smspec_type *other"
    },
    {
      "ret": "const int *",
      "name": "rd_smspec_get_index_map",
      "args": "const rd_smspec_type *smspec"
    },
    {
      "ret": "rd_smspec_var_type",
      "name": "rd_smspec_identify_var_type",
      "args": "const char *var"
    },
    {
      "ret": "rd_smspec_type *",
      "name": "rd_smspec_alloc_restart_writer",
      "args": "const char *key_join_string, const char *restart_case, int restart_step, time_t sim_start, bool time_in_days, int nx, int ny, int nz"
    },
    {
      "ret": "rd_smspec_type *",
      "name": "rd_smspec_alloc_writer",
      "args": "const char *key_join_string, time_t sim_start, bool time_in_days, int nx, int ny, int nz"
    },
    {
      "ret": "void",
      "name": "rd_smspec_fwrite",
      "args": "const rd_smspec_type *smspec, const char *rd_case, bool fmt_file"
    },
    {
      "ret": "rd_smspec_type *",
      "name": "rd_smspec_fread_alloc",
      "args": "const char *header_file, const char *key_join_string, bool include_restart"
    },
    {
      "ret": "void",
      "name": "rd_smspec_free",
      "args": "rd_smspec_type *"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_date_day_index",
      "args": "const rd_smspec_type *smspec"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_date_month_index",
      "args": "const rd_smspec_type *smspec"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_date_year_index",
      "args": "const rd_smspec_type *smspec"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_general_var_params_index",
      "args": "const rd_smspec_type *rd_smspec, const char *lookup_kw"
    },
    {
      "ret": "bool",
      "name": "rd_smspec_has_general_var",
      "args": "const rd_smspec_type *rd_smspec, const char *lookup_kw"
    },
    {
      "ret": "void",
      "name": "rd_smspec_select_matching_general_var_list",
      "args": "const rd_smspec_type *smspec, const char *pattern, stringlist_type *keys"
    },
    {
      "ret": "stringlist_type *",
      "name": "rd_smspec_alloc_matching_general_var_list",
      "args": "const rd_smspec_type *smspec, const char *pattern"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_time_seconds",
      "args": "const rd_smspec_type *rd_smspec"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_time_index",
      "args": "const rd_smspec_type *rd_smspec"
    },
    {
      "ret": "time_t",
      "name": "rd_smspec_get_start_time",
      "args": "const rd_smspec_type *"
    },
    {
      "ret": "bool",
      "name": "rd_smspec_get_formatted",
      "args": "const rd_smspec_type *rd_smspec"
    },
    {
      "ret": "const char *",
      "name": "rd_smspec_get_header_file",
      "args": "const rd_smspec_type *rd_smspec"
    },
    {
      "ret": "stringlist_type *",
      "name": "rd_smspec_alloc_well_list",
      "args": "const rd_smspec_type *smspec, const char *pattern"
    },
    {
      "ret": "stringlist_type *",
      "name": "rd_smspec_alloc_group_list",
      "args": "const rd_smspec_type *smspec, const char *pattern"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_first_step",
      "args": "const rd_smspec_type *rd_smspec"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_restart_step",
      "args": "const rd_smspec_type *rd_smspec"
    },
    {
      "ret": "const char *",
      "name": "rd_smspec_get_restart_case",
      "args": "const rd_smspec_type *rd_smspec"
    },
    {
      "ret": "const int *",
      "name": "rd_smspec_get_grid_dims",
      "args": "const rd_smspec_type *smspec"
    },
    {
      "ret": "int",
      "name": "rd_smspec_get_params_size",
      "args": "const rd_smspec_type *smspec"
    },
    {
      "ret": "int",
      "name": "rd_smspec_num_nodes",
      "args": "const rd_smspec_type *smspec"
    },
    {
      "ret": "bool",
      "name": "rd_smspec_equal",
      "args": "const rd_smspec_type *self, const rd_smspec_type *other"
    },
    {
      "ret": "ert_rd_unit_enum",
      "name": "rd_smspec_get_unit_system",
      "args": "const rd_smspec_type *smspec"
    }
  ],
  "resdata\\rd_subsidence.hpp": [
    {
      "ret": "void",
      "name": "rd_subsidence_free",
      "args": "rd_subsidence_type *rd_subsidence_config"
    },
    {
      "ret": "rd_subsidence_type *",
      "name": "rd_subsidence_alloc",
      "args": "const rd_grid_type *rd_grid, const rd_file_type *init_file"
    },
    {
      "ret": "rd_subsidence_survey_type *",
      "name": "rd_subsidence_add_survey_PRESSURE",
      "args": "rd_subsidence_type *subsidence, const char *name, const rd_file_view_type *restart_view"
    },
    {
      "ret": "bool",
      "name": "rd_subsidence_has_survey",
      "args": "const rd_subsidence_type *subsidence, const char *name"
    },
    {
      "ret": "double",
      "name": "rd_subsidence_eval",
      "args": "const rd_subsidence_type *subsidence, const char *base, const char *monitor, rd_region_type *region, double utm_x, double utm_y, double depth, double compressibility, double poisson_ratio"
    },
    {
      "ret": "double",
      "name": "rd_subsidence_eval_geertsma",
      "args": "const rd_subsidence_type *subsidence, const char *base, const char *monitor, rd_region_type *region, double utm_x, double utm_y, double depth, double youngs_modulus, double poisson_ratio, double seabed"
    },
    {
      "ret": "double",
      "name": "rd_subsidence_eval_geertsma_rporv",
      "args": "const rd_subsidence_type *subsidence, const char *base, const char *monitor, rd_region_type *region, double utm_x, double utm_y, double depth, double youngs_modulus, double poisson_ratio, double seabed"
    }
  ],
  "resdata\\rd_sum.hpp": [
    {
      "ret": "double",
      "name": "rd_sum_get_from_sim_time",
      "args": "const rd_sum_type *rd_sum, time_t sim_time, const rd::smspec_node *node"
    },
    {
      "ret": "double",
      "name": "rd_sum_time2days",
      "args": "const rd_sum_type *rd_sum, time_t sim_time"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_report_step_from_time",
      "args": "const rd_sum_type *sum, time_t sim_time"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_report_step_from_days",
      "args": "const rd_sum_type *sum, double sim_days"
    },
    {
      "ret": "bool",
      "name": "rd_sum_check_sim_time",
      "args": "const rd_sum_type *sum, time_t sim_time"
    },
    {
      "ret": "bool",
      "name": "rd_sum_check_sim_days",
      "args": "const rd_sum_type *sum, double sim_days"
    },
    {
      "ret": "const char *",
      "name": "rd_sum_get_unit",
      "args": "const rd_sum_type *sum, const char *gen_key"
    },
    {
      "ret": "double",
      "name": "rd_sum_iget",
      "args": "const rd_sum_type *rd_sum, int time_index, int param_index"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_data_length",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "void",
      "name": "rd_sum_free",
      "args": "rd_sum_type *"
    },
    {
      "ret": "rd_sum_type *",
      "name": "rd_sum_fread_alloc",
      "args": "const char *, const stringlist_type *data_files, const char *key_join_string, bool include_restart, bool lazy_load, int file_options"
    },
    {
      "ret": "rd_sum_type *",
      "name": "rd_sum_fread_alloc_case",
      "args": "const char *, const char *key_join_string"
    },
    {
      "ret": "rd_sum_type *",
      "name": "rd_sum_fread_alloc_case2__",
      "args": "const char *, const char *key_join_string, bool include_restart, bool lazy_load, int file_options"
    },
    {
      "ret": "rd_sum_type *",
      "name": "rd_sum_alloc_resample",
      "args": "const rd_sum_type *rd_sum, const char *rd_case, const time_t_vector_type *times, bool lower_extrapolation, bool upper_extrapolation"
    },
    {
      "ret": "double",
      "name": "rd_sum_get_general_var",
      "args": "const rd_sum_type *rd_sum, int time_index, const char *lookup_kw"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_general_var_params_index",
      "args": "const rd_sum_type *rd_sum, const char *lookup_kw"
    },
    {
      "ret": "const rd::smspec_node *",
      "name": "rd_sum_get_general_var_node",
      "args": "const rd_sum_type *rd_sum, const char *lookup_kw"
    },
    {
      "ret": "bool",
      "name": "rd_sum_has_general_var",
      "args": "const rd_sum_type *rd_sum, const char *lookup_kw"
    },
    {
      "ret": "bool",
      "name": "rd_sum_has_key",
      "args": "const rd_sum_type *rd_sum, const char *lookup_kw"
    },
    {
      "ret": "double",
      "name": "rd_sum_get_general_var_from_sim_days",
      "args": "const rd_sum_type *rd_sum, double sim_days, const char *var"
    },
    {
      "ret": "double",
      "name": "rd_sum_get_general_var_from_sim_time",
      "args": "const rd_sum_type *rd_sum, time_t sim_time, const char *var"
    },
    {
      "ret": "ert_rd_unit_enum",
      "name": "rd_sum_get_unit_system",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_restart_step",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_first_gt",
      "args": "const rd_sum_type *rd_sum, int param_index, double limit"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_first_lt",
      "args": "const rd_sum_type *rd_sum, int param_index, double limit"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_last_report_step",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "int",
      "name": "rd_sum_get_first_report_step",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_get_report_time",
      "args": "const rd_sum_type *rd_sum, int report_step"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_iget_sim_time",
      "args": "const rd_sum_type *rd_sum, int index"
    },
    {
      "ret": "double",
      "name": "rd_sum_iget_sim_days",
      "args": "const rd_sum_type *rd_sum, int time_index"
    },
    {
      "ret": "int",
      "name": "rd_sum_iget_report_step",
      "args": "const rd_sum_type *rd_sum, int internal_index"
    },
    {
      "ret": "double_vector_type *",
      "name": "rd_sum_alloc_data_vector",
      "args": "const rd_sum_type *rd_sum, int data_index, bool report_only"
    },
    {
      "ret": "time_t_vector_type *",
      "name": "rd_sum_alloc_time_vector",
      "args": "const rd_sum_type *rd_sum, bool report_only"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_get_data_start",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_get_end_time",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_get_start_time",
      "args": "const rd_sum_type *"
    },
    {
      "ret": "const char *",
      "name": "rd_sum_get_base",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "const char *",
      "name": "rd_sum_get_path",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "const char *",
      "name": "rd_sum_get_abs_path",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "const rd_sum_type *",
      "name": "rd_sum_get_restart_case",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "const char *",
      "name": "rd_sum_get_case",
      "args": "const rd_sum_type *"
    },
    {
      "ret": "double",
      "name": "rd_sum_get_sim_length",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "double",
      "name": "rd_sum_get_first_day",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "stringlist_type *",
      "name": "rd_sum_alloc_well_list",
      "args": "const rd_sum_type *rd_sum, const char *pattern"
    },
    {
      "ret": "stringlist_type *",
      "name": "rd_sum_alloc_group_list",
      "args": "const rd_sum_type *rd_sum, const char *pattern"
    },
    {
      "ret": "stringlist_type *",
      "name": "rd_sum_alloc_matching_general_var_list",
      "args": "const rd_sum_type *rd_sum, const char *pattern"
    },
    {
      "ret": "void",
      "name": "rd_sum_select_matching_general_var_list",
      "args": "const rd_sum_type *rd_sum, const char *pattern, stringlist_type *keys"
    },
    {
      "ret": "rd_smspec_type *",
      "name": "rd_sum_get_smspec",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "rd_smspec_var_type",
      "name": "rd_sum_identify_var_type",
      "args": "const char *var"
    },
    {
      "ret": "int",
      "name": "rd_sum_iget_report_end",
      "args": "const rd_sum_type *rd_sum, int report_step"
    },
    {
      "ret": "rd_sum_type *",
      "name": "rd_sum_alloc_restart_writer2",
      "args": "const char *rd_case, const char *restart_case, int restart_step, bool fmt_output, bool unified, const char *key_join_string, time_t sim_start, bool time_in_days, int nx, int ny, int nz"
    },
    {
      "ret": "void",
      "name": "rd_sum_set_case",
      "args": "rd_sum_type *rd_sum, const char *input_arg"
    },
    {
      "ret": "rd_sum_type *",
      "name": "rd_sum_alloc_restart_writer",
      "args": "const char *rd_case, const char *restart_case, bool fmt_output, bool unified, const char *key_join_string, time_t sim_start, bool time_in_days, int nx, int ny, int nz"
    },
    {
      "ret": "rd_sum_type *",
      "name": "rd_sum_alloc_writer",
      "args": "const char *rd_case, bool fmt_output, bool unified, const char *key_join_string, time_t sim_start, bool time_in_days, int nx, int ny, int nz"
    },
    {
      "ret": "void",
      "name": "rd_sum_fwrite",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "bool",
      "name": "rd_sum_can_write",
      "args": "const rd_sum_type *rd_sum"
    },
    {
      "ret": "const rd::smspec_node *",
      "name": "rd_sum_add_smspec_node",
      "args": "rd_sum_type *rd_sum, const rd::smspec_node *node"
    },
    {
      "ret": "const rd::smspec_node *",
      "name": "rd_sum_add_var",
      "args": "rd_sum_type *rd_sum, const char *keyword, const char *wgname, int num, const char *unit, float default_value"
    },
    {
      "ret": "const rd::smspec_node *",
      "name": "rd_sum_add_local_var",
      "args": "rd_sum_type *rd_sum, const char *keyword, const char *wgname, int num, const char *unit, const char *lgr, int lgr_i, int lgr_j, int lgr_k, float default_value"
    },
    {
      "ret": "rd_sum_tstep_type *",
      "name": "rd_sum_add_tstep",
      "args": "rd_sum_type *rd_sum, int report_step, double sim_seconds"
    },
    {
      "ret": "void",
      "name": "rd_sum_export_csv",
      "args": "const rd_sum_type *rd_sum, const char *filename, const stringlist_type *var_list, const char *date_format, const char *sep"
    },
    {
      "ret": "double_vector_type *",
      "name": "rd_sum_alloc_days_solution",
      "args": "const rd_sum_type *rd_sum, const char *gen_key, double cmp_value, bool rates_clamp_lower"
    },
    {
      "ret": "time_t_vector_type *",
      "name": "rd_sum_alloc_time_solution",
      "args": "const rd_sum_type *rd_sum, const char *gen_key, double cmp_value, bool rates_clamp_lower"
    },
    {
      "ret": "double",
      "name": "rd_sum_get_last_value_gen_key",
      "args": "const rd_sum_type *rd_sum, const char *gen_key"
    },
    {
      "ret": "double",
      "name": "rd_sum_get_first_value_gen_key",
      "args": "const rd_sum_type *rd_sum, const char *gen_key"
    },
    {
      "ret": "void",
      "name": "rd_sum_init_datetime64_vector",
      "args": "const rd_sum_type *rd_sum, int64_t *data, int multiplier"
    },
    {
      "ret": "void",
      "name": "rd_sum_init_double_vector_interp",
      "args": "const rd_sum_type *rd_sum, const char *gen_key, const time_t_vector_type *time_points, double *data"
    },
    {
      "ret": "void",
      "name": "rd_sum_init_double_vector",
      "args": "const rd_sum_type *rd_sum, const char *gen_key, double *data"
    },
    {
      "ret": "void",
      "name": "rd_sum_init_double_frame",
      "args": "const rd_sum_type *rd_sum, const rd_sum_vector_type *keywords, double *data"
    },
    {
      "ret": "void",
      "name": "rd_sum_init_double_frame_interp",
      "args": "const rd_sum_type *rd_sum, const rd_sum_vector_type *keywords, const time_t_vector_type *time_points, double *data"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "rd_sum"
    }
  ],
  "resdata\\rd_sum_data.hpp": [
    {
      "ret": "void",
      "name": "rd_sum_data_add_case",
      "args": "rd_sum_data_type *self, const rd_sum_data_type *other"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_fwrite",
      "args": "const rd_sum_data_type *data, const char *rd_case, bool fmt_case, bool unified"
    },
    {
      "ret": "bool",
      "name": "rd_sum_data_can_write",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "bool",
      "name": "rd_sum_data_fread",
      "args": "rd_sum_data_type *data, const stringlist_type *filelist, bool lazy_load, int file_options"
    },
    {
      "ret": "rd_sum_data_type *",
      "name": "rd_sum_data_alloc_writer",
      "args": "rd_smspec_type *smspec"
    },
    {
      "ret": "rd_sum_data_type *",
      "name": "rd_sum_data_alloc",
      "args": "rd_smspec_type *smspec"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_time2days",
      "args": "const rd_sum_data_type *data, time_t sim_time"
    },
    {
      "ret": "int",
      "name": "rd_sum_data_get_report_step_from_time",
      "args": "const rd_sum_data_type *data, time_t sim_time"
    },
    {
      "ret": "int",
      "name": "rd_sum_data_get_report_step_from_days",
      "args": "const rd_sum_data_type *data, double days"
    },
    {
      "ret": "bool",
      "name": "rd_sum_data_check_sim_time",
      "args": "const rd_sum_data_type *data, time_t sim_time"
    },
    {
      "ret": "bool",
      "name": "rd_sum_data_check_sim_days",
      "args": "const rd_sum_data_type *data, double sim_days"
    },
    {
      "ret": "double_vector_type *",
      "name": "rd_sum_data_alloc_data_vector",
      "args": "const rd_sum_data_type *data, int data_index, bool report_only"
    },
    {
      "ret": "time_t_vector_type *",
      "name": "rd_sum_data_alloc_time_vector",
      "args": "const rd_sum_data_type *data, bool report_only"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_data_get_data_start",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_data_get_report_time",
      "args": "const rd_sum_data_type *data, int report_step"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_get_first_day",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_data_get_sim_end",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_get_sim_length",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_iget",
      "args": "const rd_sum_data_type *data, int internal_index, int params_index"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_iget_sim_days",
      "args": "const rd_sum_data_type *, int"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_data_iget_sim_time",
      "args": "const rd_sum_data_type *, int"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_get_interp_vector",
      "args": "const rd_sum_data_type *data, time_t sim_time, const rd_sum_vector_type *keylist, double_vector_type *results"
    },
    {
      "ret": "bool",
      "name": "rd_sum_data_has_report_step",
      "args": "const rd_sum_data_type *, int"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_free",
      "args": "rd_sum_data_type *"
    },
    {
      "ret": "int",
      "name": "rd_sum_data_get_last_report_step",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "int",
      "name": "rd_sum_data_get_first_report_step",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_get_from_sim_time",
      "args": "const rd_sum_data_type *data, time_t sim_time, const rd::smspec_node &smspec_node"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_get_from_sim_days",
      "args": "const rd_sum_data_type *data, double sim_days, const rd::smspec_node &smspec_node"
    },
    {
      "ret": "int",
      "name": "rd_sum_data_get_length",
      "args": "const rd_sum_data_type *data"
    },
    {
      "ret": "int",
      "name": "rd_sum_data_iget_report_step",
      "args": "const rd_sum_data_type *data, int internal_index"
    },
    {
      "ret": "int",
      "name": "rd_sum_data_iget_report_end",
      "args": "const rd_sum_data_type *data, int report_step"
    },
    {
      "ret": "rd_sum_tstep_type *",
      "name": "rd_sum_data_add_new_tstep",
      "args": "rd_sum_data_type *data, int report_step, double sim_seconds"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_fwrite_interp_csv_line",
      "args": "const rd_sum_data_type *data, time_t sim_time, const rd_sum_vector_type *keylist, FILE *fp"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_iget_last_value",
      "args": "const rd_sum_data_type *data, int param_index"
    },
    {
      "ret": "double",
      "name": "rd_sum_data_iget_first_value",
      "args": "const rd_sum_data_type *data, int param_index"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_init_double_vector",
      "args": "const rd_sum_data_type *data, int params_index, double *output_data"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_init_datetime64_vector",
      "args": "const rd_sum_data_type *data, int64_t *output_data, int multiplier"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_init_double_frame",
      "args": "const rd_sum_data_type *data, const rd_sum_vector_type *keywords, double *output_data"
    },
    {
      "ret": "double_vector_type *",
      "name": "rd_sum_data_alloc_seconds_solution",
      "args": "const rd_sum_data_type *data, const rd::smspec_node &node, double value, bool rates_clamp_lower"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_init_double_frame_interp",
      "args": "const rd_sum_data_type *data, const rd_sum_vector_type *keywords, const time_t_vector_type *time_points, double *output_data"
    },
    {
      "ret": "void",
      "name": "rd_sum_data_init_double_vector_interp",
      "args": "const rd_sum_data_type *data, const rd::smspec_node &smspec_node, const time_t_vector_type *time_points, double *output_data"
    }
  ],
  "resdata\\rd_sum_tstep.hpp": [
    {
      "ret": "void",
      "name": "rd_sum_tstep_free",
      "args": "rd_sum_tstep_type *ministep"
    },
    {
      "ret": "void",
      "name": "rd_sum_tstep_free__",
      "args": "void *__ministep"
    },
    {
      "ret": "rd_sum_tstep_type *",
      "name": "rd_sum_tstep_alloc_from_file",
      "args": "int report_step, int ministep_nr, const rd_kw_type *params_kw, const char *src_file, const rd_smspec_type *smspec"
    },
    {
      "ret": "rd_sum_tstep_type *",
      "name": "rd_sum_tstep_alloc_new",
      "args": "int report_step, int ministep, float sim_seconds, const rd_smspec_type *smspec"
    },
    {
      "ret": "void",
      "name": "rd_sum_tstep_set_from_node",
      "args": "rd_sum_tstep_type *tstep, const rd::smspec_node &smspec_node, float value"
    },
    {
      "ret": "double",
      "name": "rd_sum_tstep_get_from_node",
      "args": "const rd_sum_tstep_type *tstep, const rd::smspec_node &smspec_node"
    },
    {
      "ret": "double",
      "name": "rd_sum_tstep_iget",
      "args": "const rd_sum_tstep_type *ministep, int index"
    },
    {
      "ret": "time_t",
      "name": "rd_sum_tstep_get_sim_time",
      "args": "const rd_sum_tstep_type *ministep"
    },
    {
      "ret": "double",
      "name": "rd_sum_tstep_get_sim_days",
      "args": "const rd_sum_tstep_type *ministep"
    },
    {
      "ret": "double",
      "name": "rd_sum_tstep_get_sim_seconds",
      "args": "const rd_sum_tstep_type *ministep"
    },
    {
      "ret": "int",
      "name": "rd_sum_tstep_get_report",
      "args": "const rd_sum_tstep_type *ministep"
    },
    {
      "ret": "int",
      "name": "rd_sum_tstep_get_ministep",
      "args": "const rd_sum_tstep_type *ministep"
    },
    {
      "ret": "void",
      "name": "rd_sum_tstep_fwrite",
      "args": "const rd_sum_tstep_type *ministep, const int *index_map, int index_map_size, fortio_type *fortio"
    },
    {
      "ret": "void",
      "name": "rd_sum_tstep_iset",
      "args": "rd_sum_tstep_type *tstep, int index, float value"
    },
    {
      "ret": "void",
      "name": "rd_sum_tstep_set_from_key",
      "args": "rd_sum_tstep_type *tstep, const char *gen_key, float value"
    },
    {
      "ret": "double",
      "name": "rd_sum_tstep_get_from_key",
      "args": "const rd_sum_tstep_type *tstep, const char *gen_key"
    },
    {
      "ret": "bool",
      "name": "rd_sum_tstep_has_key",
      "args": "const rd_sum_tstep_type *tstep, const char *gen_key"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "rd_sum_tstep"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER_CONST",
      "args": "rd_sum_tstep"
    }
  ],
  "resdata\\rd_sum_vector.hpp": [
    {
      "ret": "void",
      "name": "rd_sum_vector_free",
      "args": "rd_sum_vector_type *keylist"
    },
    {
      "ret": "rd_sum_vector_type *",
      "name": "rd_sum_vector_alloc",
      "args": "const rd_sum_type *rd_sum, bool add_keywords"
    },
    {
      "ret": "bool",
      "name": "rd_sum_vector_add_key",
      "args": "rd_sum_vector_type *keylist, const char *key"
    },
    {
      "ret": "void",
      "name": "rd_sum_vector_add_keys",
      "args": "rd_sum_vector_type *keylist, const char *pattern"
    },
    {
      "ret": "const char *",
      "name": "rd_sum_vector_iget_key",
      "args": "const rd_sum_vector_type *rd_sum_vector, int index"
    },
    {
      "ret": "bool",
      "name": "rd_sum_vector_iget_is_rate",
      "args": "const rd_sum_vector_type *rd_sum_vector, int index"
    },
    {
      "ret": "int",
      "name": "rd_sum_vector_iget_param_index",
      "args": "const rd_sum_vector_type *rd_sum_vector, int index"
    },
    {
      "ret": "int",
      "name": "rd_sum_vector_get_size",
      "args": "const rd_sum_vector_type *rd_sum_vector"
    },
    {
      "ret": "bool",
      "name": "rd_sum_vector_iget_valid",
      "args": "const rd_sum_vector_type *rd_sum_vector, int index"
    },
    {
      "ret": "rd_sum_vector_type *",
      "name": "rd_sum_vector_alloc_layout_copy",
      "args": "const rd_sum_vector_type *src_vector, const rd_sum_type *rd_sum"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "rd_sum_vector"
    }
  ],
  "resdata\\rd_type.hpp": [
    {
      "ret": "rd_data_type",
      "name": "rd_type_create_from_name",
      "args": "const char *"
    },
    {
      "ret": "rd_data_type",
      "name": "rd_type_create",
      "args": "const rd_type_enum, const size_t"
    },
    {
      "ret": "rd_data_type",
      "name": "rd_type_create_from_type",
      "args": "const rd_type_enum"
    },
    {
      "ret": "rd_type_enum",
      "name": "rd_type_get_type",
      "args": "const rd_data_type"
    },
    {
      "ret": "char *",
      "name": "rd_type_alloc_name",
      "args": "const rd_data_type"
    },
    {
      "ret": "int",
      "name": "rd_type_get_sizeof_ctype",
      "args": "const rd_data_type"
    },
    {
      "ret": "int",
      "name": "rd_type_get_sizeof_iotype",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_equal",
      "args": "const rd_data_type, const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_numeric",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_alpha",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_char",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_int",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_float",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_double",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_mess",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_bool",
      "args": "const rd_data_type"
    },
    {
      "ret": "bool",
      "name": "rd_type_is_string",
      "args": "const rd_data_type"
    }
  ],
  "resdata\\rd_units.hpp": [
    {
      "ret": "#define",
      "name": "RD_UNITS_CUBIC",
      "args": "x) ((x) * (x) * (x)"
    },
    {
      "ret": "#define",
      "name": "RD_UNITS_MILLI",
      "args": "x) ((x) * 0.001"
    },
    {
      "ret": "#define",
      "name": "RD_UNITS_MEGA",
      "args": "x) ((x) * 1000000"
    },
    {
      "ret": "#define RD_UNITS_VOLUME_GALLON 231 *",
      "name": "RD_UNITS_CUBIC",
      "args": "RD_UNITS_LENGTH_INCH"
    },
    {
      "ret": "#define RD_UNITS_VOLUME_MILLI_LITER",
      "name": "RD_UNITS_MILLI",
      "args": "RD_UNITS_VOLUME_LITER"
    },
    {
      "ret": "",
      "name": "RD_UNITS_MEGA",
      "args": "RD_UNITS_CUBIC(RD_UNITS_LENGTH_FEET)"
    }
  ],
  "resdata\\rd_util.hpp": [
    {
      "ret": "int",
      "name": "rd_filename_report_nr",
      "args": "const char *"
    },
    {
      "ret": "rd_file_enum",
      "name": "rd_get_file_type",
      "args": "const char *filename, bool *fmt_file, int *report_nr"
    },
    {
      "ret": "char *",
      "name": "rd_alloc_filename",
      "args": "const char * /* path */, const char * /* base */, rd_file_enum, bool /* fmt_file */, int /*report_nr*/"
    },
    {
      "ret": "char *",
      "name": "rd_alloc_exfilename",
      "args": "const char * /* path */, const char * /* base */, rd_file_enum, bool /* fmt_file */, int /*report_nr*/"
    },
    {
      "ret": "bool",
      "name": "rd_alloc_summary_files",
      "args": "const char *, const char *, const char *, char **, stringlist_type *"
    },
    {
      "ret": "time_t",
      "name": "rd_get_start_date",
      "args": "const char *"
    },
    {
      "ret": "int",
      "name": "rd_get_num_cpu",
      "args": "const char *data_file"
    },
    {
      "ret": "bool",
      "name": "rd_fmt_file",
      "args": "const char *filename, bool *__fmt_file"
    },
    {
      "ret": "int",
      "name": "rd_fname_report_cmp",
      "args": "const void *f1, const void *f2"
    },
    {
      "ret": "time_t",
      "name": "rd_make_date",
      "args": "int mday, int month, int year"
    },
    {
      "ret": "time_t",
      "name": "rd_make_date__",
      "args": "int mday, int month, int year, int *year_offset"
    },
    {
      "ret": "time_t",
      "name": "rd_make_datetime",
      "args": "int sec, int min, int hour, int mday, int month, int year"
    },
    {
      "ret": "const char *",
      "name": "rd_get_phase_name",
      "args": "rd_phase_enum phase"
    },
    {
      "ret": "int",
      "name": "rd_select_filelist",
      "args": "const char *path, const char *base, rd_file_enum file_type, bool fmt_file, stringlist_type *filelist"
    },
    {
      "ret": "void",
      "name": "rd_set_date_values",
      "args": "time_t t, int *mday, int *month, int *year"
    },
    {
      "ret": "void",
      "name": "rd_set_datetime_values",
      "args": "time_t t, int *sec, int *min, int *hour, int *mday, int *month, int *year"
    },
    {
      "ret": "bool",
      "name": "rd_path_access",
      "args": "const char *rd_case"
    }
  ],
  "resdata\\well\\well_branch_collection.hpp": [
    {
      "ret": "well_branch_collection_type *",
      "name": "well_branch_collection_alloc",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "well_branch_collection_free",
      "args": "well_branch_collection_type *branches"
    },
    {
      "ret": "bool",
      "name": "well_branch_collection_has_branch",
      "args": "const well_branch_collection_type *branches, int branch_id"
    },
    {
      "ret": "int",
      "name": "well_branch_collection_get_size",
      "args": "const well_branch_collection_type *branches"
    },
    {
      "ret": "const well_segment_type *",
      "name": "well_branch_collection_iget_start_segment",
      "args": "const well_branch_collection_type *branches, int index"
    },
    {
      "ret": "const well_segment_type *",
      "name": "well_branch_collection_get_start_segment",
      "args": "const well_branch_collection_type *branches, int branch_id"
    },
    {
      "ret": "bool",
      "name": "well_branch_collection_add_start_segment",
      "args": "well_branch_collection_type *branches, well_segment_type *start_segment"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "well_branch_collection"
    }
  ],
  "resdata\\well\\well_conn.hpp": [
    {
      "ret": "void",
      "name": "well_conn_free",
      "args": "well_conn_type *conn"
    },
    {
      "ret": "well_conn_type *",
      "name": "well_conn_alloc",
      "args": "int i, int j, int k, double connection_factor, well_conn_dir_enum dir, bool open"
    },
    {
      "ret": "well_conn_type *",
      "name": "well_conn_alloc_MSW",
      "args": "int i, int j, int k, double connection_factor, well_conn_dir_enum dir, bool open, int segment"
    },
    {
      "ret": "well_conn_type *",
      "name": "well_conn_alloc_fracture",
      "args": "int i, int j, int k, double connection_factor, well_conn_dir_enum dir, bool open"
    },
    {
      "ret": "well_conn_type *",
      "name": "well_conn_alloc_fracture_MSW",
      "args": "int i, int j, int k, double connection_factor, well_conn_dir_enum dir, bool open, int segment"
    },
    {
      "ret": "bool",
      "name": "well_conn_MSW",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "well_conn_type *",
      "name": "well_conn_alloc_from_kw",
      "args": "const rd_kw_type *icon_kw, const rd_kw_type *scon_kw, const rd_kw_type *xcon_kw, const rd_rsthead_type *header, int well_nr, int conn_nr"
    },
    {
      "ret": "well_conn_type *",
      "name": "well_conn_alloc_wellhead",
      "args": "const rd_kw_type *iwel_kw, const rd_rsthead_type *header, int well_nr"
    },
    {
      "ret": "int",
      "name": "well_conn_get_i",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "int",
      "name": "well_conn_get_j",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "int",
      "name": "well_conn_get_k",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "well_conn_dir_enum",
      "name": "well_conn_get_dir",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "bool",
      "name": "well_conn_open",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "int",
      "name": "well_conn_get_segment_id",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "bool",
      "name": "well_conn_fracture_connection",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "bool",
      "name": "well_conn_matrix_connection",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "bool",
      "name": "well_conn_equal",
      "args": "const well_conn_type *conn1, const well_conn_type *conn2"
    },
    {
      "ret": "double",
      "name": "well_conn_get_connection_factor",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_oil_rate",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_gas_rate",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_water_rate",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_volume_rate",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_oil_rate_si",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_gas_rate_si",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_water_rate_si",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "double",
      "name": "well_conn_get_volume_rate_si",
      "args": "const well_conn_type *conn"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "well_conn"
    },
    {
      "ret": "",
      "name": "UTIL_SAFE_CAST_HEADER",
      "args": "well_conn"
    }
  ],
  "resdata\\well\\well_conn_collection.hpp": [
    {
      "ret": "well_conn_collection_type *",
      "name": "well_conn_collection_alloc",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "well_conn_collection_free",
      "args": "well_conn_collection_type *wellcc"
    },
    {
      "ret": "int",
      "name": "well_conn_collection_get_size",
      "args": "const well_conn_collection_type *wellcc"
    },
    {
      "ret": "const well_conn_type *",
      "name": "well_conn_collection_iget_const",
      "args": "const well_conn_collection_type *wellcc, int index"
    },
    {
      "ret": "well_conn_type *",
      "name": "well_conn_collection_iget",
      "args": "const well_conn_collection_type *wellcc, int index"
    },
    {
      "ret": "void",
      "name": "well_conn_collection_add",
      "args": "well_conn_collection_type *wellcc, well_conn_type *conn"
    },
    {
      "ret": "void",
      "name": "well_conn_collection_add_ref",
      "args": "well_conn_collection_type *wellcc, well_conn_type *conn"
    },
    {
      "ret": "int",
      "name": "well_conn_collection_load_from_kw",
      "args": "well_conn_collection_type *wellcc, const rd_kw_type *iwel_kw, const rd_kw_type *icon_kw, const rd_kw_type *scon_kw, const rd_kw_type *xcon_kw, int iwell, const rd_rsthead_type *rst_head"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "well_conn_collection"
    }
  ],
  "resdata\\well\\well_info.hpp": [
    {
      "ret": "well_info_type *",
      "name": "well_info_alloc",
      "args": "const rd_grid_type *grid"
    },
    {
      "ret": "void",
      "name": "well_info_load_rstfile",
      "args": "well_info_type *well_info, const char *filename, bool load_segment_information"
    },
    {
      "ret": "void",
      "name": "well_info_load_rst_resfile",
      "args": "well_info_type *well_info, rd_file_type *rst_file, bool load_segment_information"
    },
    {
      "ret": "void",
      "name": "well_info_free",
      "args": "well_info_type *well_info"
    },
    {
      "ret": "well_ts_type *",
      "name": "well_info_get_ts",
      "args": "const well_info_type *well_info, const char *well_name"
    },
    {
      "ret": "int",
      "name": "well_info_get_num_wells",
      "args": "const well_info_type *well_info"
    },
    {
      "ret": "const char *",
      "name": "well_info_iget_well_name",
      "args": "const well_info_type *well_info, int well_index"
    },
    {
      "ret": "bool",
      "name": "well_info_has_well",
      "args": "well_info_type *well_info, const char *well_name"
    }
  ],
  "resdata\\well\\well_rseg_loader.hpp": [
    {
      "ret": "well_rseg_loader_type *",
      "name": "well_rseg_loader_alloc",
      "args": "rd_file_view_type *rst_view"
    },
    {
      "ret": "void",
      "name": "well_rseg_loader_free",
      "args": "well_rseg_loader_type *well_rseg_loader"
    },
    {
      "ret": "double *",
      "name": "well_rseg_loader_load_values",
      "args": "const well_rseg_loader_type *well_rseg_loader, int rseg_offset"
    }
  ],
  "resdata\\well\\well_segment.hpp": [
    {
      "ret": "well_segment_type *",
      "name": "well_segment_alloc_from_kw",
      "args": "const rd_kw_type *iseg_kw, const well_rseg_loader_type *rseg_loader, const rd_rsthead_type *header, int well_nr, int segment_index, int segment_id"
    },
    {
      "ret": "well_segment_type *",
      "name": "well_segment_alloc",
      "args": "int segment_id, int outlet_segment_id, int branch_id, const double *rseg_data"
    },
    {
      "ret": "void",
      "name": "well_segment_free",
      "args": "well_segment_type *segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_active",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_main_stem",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_nearest_wellhead",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "int",
      "name": "well_segment_get_link_count",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "int",
      "name": "well_segment_get_branch_id",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "int",
      "name": "well_segment_get_outlet_id",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "int",
      "name": "well_segment_get_id",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "well_segment_type *",
      "name": "well_segment_get_outlet",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_link",
      "args": "well_segment_type *segment, well_segment_type *outlet_segment"
    },
    {
      "ret": "void",
      "name": "well_segment_link_strict",
      "args": "well_segment_type *segment, well_segment_type *outlet_segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_has_grid_connections",
      "args": "const well_segment_type *segment, const char *grid_name"
    },
    {
      "ret": "bool",
      "name": "well_segment_has_global_grid_connections",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_add_connection",
      "args": "well_segment_type *segment, const char *grid_name, well_conn_type *conn"
    },
    {
      "ret": "const well_conn_collection_type *",
      "name": "well_segment_get_connections",
      "args": "const well_segment_type *segment, const char *grid_name"
    },
    {
      "ret": "const well_conn_collection_type *",
      "name": "well_segment_get_global_connections",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_well_is_MSW",
      "args": "int well_nr, const rd_kw_type *iwel_kw, const rd_rsthead_type *rst_head"
    },
    {
      "ret": "double",
      "name": "well_segment_get_depth",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "double",
      "name": "well_segment_get_length",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "double",
      "name": "well_segment_get_total_length",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "double",
      "name": "well_segment_get_diameter",
      "args": "const well_segment_type *segment"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "well_segment"
    }
  ],
  "resdata\\well\\well_segment_collection.hpp": [
    {
      "ret": "well_segment_collection_type *",
      "name": "well_segment_collection_alloc",
      "args": "void"
    },
    {
      "ret": "void",
      "name": "well_segment_collection_free",
      "args": "well_segment_collection_type *segment_collection"
    },
    {
      "ret": "int",
      "name": "well_segment_collection_get_size",
      "args": "const well_segment_collection_type *segment_collection"
    },
    {
      "ret": "void",
      "name": "well_segment_collection_add",
      "args": "well_segment_collection_type *segment_collection, well_segment_type *segment"
    },
    {
      "ret": "bool",
      "name": "well_segment_collection_has_segment",
      "args": "const well_segment_collection_type *segment_collection, int segment_id"
    },
    {
      "ret": "well_segment_type *",
      "name": "well_segment_collection_get",
      "args": "const well_segment_collection_type *segment_collection, int segment_id"
    },
    {
      "ret": "well_segment_type *",
      "name": "well_segment_collection_iget",
      "args": "const well_segment_collection_type *segment_collection, int index"
    },
    {
      "ret": "int",
      "name": "well_segment_collection_load_from_kw",
      "args": "well_segment_collection_type *segment_collection, int well_nr, const rd_kw_type *iwel_kw, const rd_kw_type *iseg_kw, const well_rseg_loader_type *rseg_loader, const rd_rsthead_type *rst_head, bool load_segment_information, bool *is_MSW_well"
    },
    {
      "ret": "void",
      "name": "well_segment_collection_link",
      "args": "const well_segment_collection_type *segment_collection"
    },
    {
      "ret": "void",
      "name": "well_segment_collection_add_connections",
      "args": "well_segment_collection_type *segment_collection, const char *grid_name, const well_conn_collection_type *connections"
    },
    {
      "ret": "void",
      "name": "well_segment_collection_add_branches",
      "args": "const well_segment_collection_type *segment_collection, well_branch_collection_type *branches"
    }
  ],
  "resdata\\well\\well_state.hpp": [
    {
      "ret": "well_state_type *",
      "name": "well_state_alloc",
      "args": "const char *well_name, int global_well_nr, bool open, well_type_enum type, int report_nr, time_t valid_from"
    },
    {
      "ret": "well_state_type *",
      "name": "well_state_alloc_from_file",
      "args": "rd_file_type *rd_file, const rd_grid_type *grid, int report_step, int well_nr, bool load_segment_information"
    },
    {
      "ret": "well_state_type *",
      "name": "well_state_alloc_from_file2",
      "args": "rd_file_view_type *file_view, const rd_grid_type *grid, int report_nr, int global_well_nr, bool load_segment_information"
    },
    {
      "ret": "void",
      "name": "well_state_add_connections2",
      "args": "well_state_type *well_state, const rd_grid_type *grid, rd_file_view_type *rst_view, int well_nr"
    },
    {
      "ret": "bool",
      "name": "well_state_add_MSW2",
      "args": "well_state_type *well_state, rd_file_view_type *rst_view, int well_nr, bool load_segment_information"
    },
    {
      "ret": "bool",
      "name": "well_state_is_MSW",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "bool",
      "name": "well_state_has_segment_data",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "well_segment_collection_type *",
      "name": "well_state_get_segments",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "well_branch_collection_type *",
      "name": "well_state_get_branches",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "void",
      "name": "well_state_free",
      "args": "well_state_type *well"
    },
    {
      "ret": "const char *",
      "name": "well_state_get_name",
      "args": "const well_state_type *well"
    },
    {
      "ret": "int",
      "name": "well_state_get_report_nr",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "time_t",
      "name": "well_state_get_sim_time",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "well_type_enum",
      "name": "well_state_get_type",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "bool",
      "name": "well_state_is_open",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "int",
      "name": "well_state_get_well_nr",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "const well_conn_type *",
      "name": "well_state_get_global_wellhead",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "well_type_enum",
      "name": "well_state_translate_rd_type_int",
      "args": "int int_type"
    },
    {
      "ret": "const well_conn_collection_type *",
      "name": "well_state_get_grid_connections",
      "args": "const well_state_type *well_state, const char *grid_name"
    },
    {
      "ret": "const well_conn_collection_type *",
      "name": "well_state_get_global_connections",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "bool",
      "name": "well_state_has_grid_connections",
      "args": "const well_state_type *well_state, const char *grid_name"
    },
    {
      "ret": "bool",
      "name": "well_state_has_global_connections",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_oil_rate",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_gas_rate",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_water_rate",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_volume_rate",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_water_rate_si",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_oil_rate_si",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_volume_rate_si",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "double",
      "name": "well_state_get_gas_rate_si",
      "args": "const well_state_type *well_state"
    },
    {
      "ret": "",
      "name": "UTIL_IS_INSTANCE_HEADER",
      "args": "well_state"
    }
  ],
  "resdata\\well\\well_ts.hpp": [
    {
      "ret": "void",
      "name": "well_ts_free",
      "args": "well_ts_type *well_ts"
    },
    {
      "ret": "void",
      "name": "well_ts_add_well",
      "args": "well_ts_type *well_ts, well_state_type *well_state"
    },
    {
      "ret": "well_ts_type *",
      "name": "well_ts_alloc",
      "args": "const char *well_name"
    },
    {
      "ret": "well_state_type *",
      "name": "well_ts_iget_state",
      "args": "const well_ts_type *well_ts, int index"
    },
    {
      "ret": "int",
      "name": "well_ts_get_size",
      "args": "const well_ts_type *well_ts"
    },
    {
      "ret": "const char *",
      "name": "well_ts_get_name",
      "args": "const well_ts_type *well_ts"
    },
    {
      "ret": "well_state_type *",
      "name": "well_ts_get_last_state",
      "args": "const well_ts_type *well_ts"
    }
  ]
}